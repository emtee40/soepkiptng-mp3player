############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

use Socket;

sub del_song($@) {
	my ($db, @ids) = @_;
	@ids or return;
	$db->do("DELETE FROM queue WHERE song_id=" . join(" OR song_id=", @ids));
}

sub add_song_nolock($$@) {
	my ($db, $order, @ids) = @_;

	my $firstid = shift @ids or return;
	my $q = "INSERT INTO queue (song_order,song_id) VALUES ($order,$firstid)";
	foreach(@ids) {
		$order++;
		$q .= ",($order,$_)";
	}
	$db->do($q);
}

sub get_queue_ids($$) {
	my ($db, $orderby) = @_;

	my $res = $db->selectcol_arrayref("SELECT song_id FROM queue ORDER BY $orderby");
	return @$res;
}


sub add_song($@) {
	my ($db, @ids) = @_;

	$db->do("LOCK TABLES queue WRITE");
	del_song($db, @ids);
	my ($order) = $db->selectrow_array("SELECT MAX(song_order) FROM queue");
	$order = 0 if $order < 0;
	add_song_nolock($db, $order + 1, @ids);
	$db->do("UNLOCK TABLES");
}

sub move_song_to_top($@) {
	my ($db, @ids) = @_;

	$db->do("LOCK TABLES queue WRITE");

	del_song($db, @ids);

	my @res = get_queue_ids($db, "song_order");
	$db->do("DELETE FROM queue");
	add_song_nolock($db, 1, (@ids, @res));

	$db->do("UNLOCK TABLES");
}

sub shuffle_queue($) {
	my ($db) = @_;

	$db->do("LOCK TABLES queue WRITE");

	my @res = get_queue_ids($db, "rand()");
	$db->do("DELETE FROM queue");
	add_song_nolock($db, 1, @res);

	$db->do("UNLOCK TABLES");
}

sub kill_song() {
	if($kill_song_external) {
		system $kill_song_external;

		open F, $statusfile
			or die "$statusfile: $!\n";
		my @lines;
		chop(@lines = <F>);
		close F;
		return @lines;
	}
	return kill_song_internal();
}

sub kill_song_internal() {
	local *F;

	open F, $statusfile
		or die "$statusfile: $!\n";
	<F>; <F>; <F>; <F>;
	chop($host = <F>);
	$port = <F>;
	close F;

	$host && $port or return undef;

	socket(F, PF_INET, SOCK_STREAM, getprotobyname('tcp'))
		or die "socket: $!\n";
	connect(F, sockaddr_in($port, inet_aton($host)))
		or die "connect $host:$port: $!\n";
	my @status;
	@status = <F>;
	close F;
	return @status;
}

sub get_id($$$) {
	my ($db, $table, $value) = @_;

	my $sth = $db->prepare("SELECT id,name FROM $table WHERE binary name=?");
	if($sth->execute($value) >= 1) {
		my ($id, $v) = $sth->fetchrow_array;

#		# "gt" works case-insensitively !@#!@#%$@#, compare byte-by-byte
#		my ($vvalue, $vv) = ($value, $v);
#		while($vvalue) {
#			last if ord($vvalue) > ord($vv);
#			if(ord($vvalue) < ord($vv)) {
#				$db->do("UPDATE $table SET name=? WHERE id=?", undef, $value, $id)
#					or die;
#				last;
#			}
#			$vvalue =~ s/.//;
#			$vv =~ s/.//;
#		}
		return $id;
	} else {
		$db->do("REPLACE INTO $table SET name=?", undef, $value)
			or die;
		return $db->{'mysql_insertid'};
	}
}

sub get_playlist_contents($$) {
	my ($dbh, $list) = @_;
	my %songids;
	my %artistids, %albumsids, %listids;
	my %artistids_done, %albumsids_done, %listids_done;

	my $sth_list = $dbh->prepare("SELECT type,entity_id" .
		" FROM list_contents WHERE list_id=?");
	my $sth_artist = $dbh->prepare("SELECT id FROM song WHERE artist_id=?");
	my $sth_album = $dbh->prepare("SELECT id FROM song WHERE album_id=?");
	
	$listids{$list} = 1;
	while(%artistids || %albumsids || %listids) {
		foreach(keys %listids) {
			$listids_done{$_} = 1;
			delete $listids{$_};

			$sth_list->execute($_);
			while($_ = $sth_list->fetchrow_hashref) {
				if($_->{'type'} eq 'list') {
					next if $listids_done{$_->{'entity_id'}};
					$listids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'artist') {
					next if $artistids_done{$_->{'entity_id'}};
					$artistids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'album') {
					next if $albumids_done{$_->{'entity_id'}};
					$albumids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'song') {
					$songids{$_->{'entity_id'}} = 1;
				}
			}
		}
		foreach(keys %artistids) {
			$artistids_done{$_} = 1;
			delete $artistids{$_};

			$sth_artist->execute($_);
			while($_ = $sth_artist->fetchrow_hashref) {
				$songids{$_->{'id'}} = 1;
			}
		}
		foreach(keys %albumids) {
			$albumids_done{$_} = 1;
			delete $albumids{$_};

			$sth_album->execute($_);
			while($_ = $sth_album->fetchrow_hashref) {
				$songids{$_->{'id'}} = 1;
			}
		}
	}
	return keys %songids;
}

sub construct_url($@) {
	my ($baseurl, $argsref) = @_;
	my $sep = "?";
	foreach(keys %$argsref) {
		$baseurl .= "$sep$_=" . encode($$argsref{$_});
		$sep = "&";
	}
	return $baseurl;
}

1;

############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

use IO::Socket;
use Socket;

my @globalconfigfiles = ($ENV{SOEPKIPTNG_CONFIGFILE},
   "$ENV{HOME}/.soepkiptng.conf", "/etc/soepkiptng.conf");

sub read_configfile($;@) {
	my ($conf, @extraconfigfiles) = @_;
	my $cf;

	foreach $cf ((@extraconfigfiles, @globalconfigfiles)) {
		local *F;
		defined($cf) && -f $cf or next;
		open F, $cf or next;
		while(<F>) {
			/^#/ and next;
			s/\s+$//;
			/./ or next;
			if(/^(\w+)\s*=\s*(.*?)\s*$/) {
				$f = $1;
				$conf->{$f} = $2;
			} elsif(/^\s+(.*?)\s*$/) {
				# continuation line
				$conf->{$f} .= "\n$1";
			} else {
				die "$cf line $.: invalid format\n";
			}
		}
		close F;
		return;
	}
	die sprintf "no configuration file found (tried %s)\n",
		join(" ", @extraconfigfiles, @globalconfigfiles);
}

%latin1toascii = (
	192 => 'A',		# capital A, grave accent
	193 => 'A',		# capital A, acute accent
	194 => 'A',		# capital A, circumflex accent
	195 => 'A',		# capital A, tilde
	196 => 'A',		# capital A, dieresis or umlaut mark
	197 => 'AA',		# capital A, ring
	198 => 'AE',		# capital AE diphthong (ligature)
	199 => 'C',		# capital C, cedilla
	200 => 'E',		# capital E, grave accent
	201 => 'E',		# capital E, acute accent
	202 => 'E',		# capital E, circumflex accent
	203 => 'E',		# capital E, dieresis or umlaut mark
	204 => 'I',		# capital I, grave accent
	205 => 'I',		# capital I, acute accent
	206 => 'I',		# capital I, circumflex accent
	207 => 'I',		# capital I, dieresis or umlaut mark
	209 => 'N',		# capital N, tilde
	210 => 'O',		# capital O, grave accent
	211 => 'O',		# capital O, acute accent
	212 => 'O',		# capital O, circumflex accent
	213 => 'O',		# capital O, tilde
	214 => 'O',		# capital O, dieresis or umlaut mark
	216 => 'O',		# capital O, slash
	217 => 'U',		# capital U, grave accent
	218 => 'U',		# capital U, acute accent
	219 => 'U',		# capital U, circumflex accent
	220 => 'U',		# capital U, dieresis or umlaut mark
	221 => 'Y',		# capital Y, acute accent
	223 => 'ss',		# small sharp s, German (sz ligature)
	224 => 'a',		# small a, grave accent
	225 => 'a',		# small a, acute accent
	226 => 'a',		# small a, circumflex accent
	227 => 'a',		# small a, tilde
	228 => 'a',		# small a, dieresis or umlaut mark
	229 => 'aa',		# small a, ring
	230 => 'ae',		# small ae diphthong (ligature)
	231 => 'c',		# small c, cedilla
	232 => 'e',		# small e, grave accent
	233 => 'e',		# small e, acute accent
	234 => 'e',		# small e, circumflex accent
	235 => 'e',		# small e, dieresis or umlaut mark
	236 => 'i',		# small i, grave accent
	237 => 'i',		# small i, acute accent
	238 => 'i',		# small i, circumflex accent
	239 => 'i',		# small i, dieresis or umlaut mark
	241 => 'n',		# small n, tilde
	242 => 'o',		# small o, grave accent
	243 => 'o',		# small o, acute accent
	244 => 'o',		# small o, circumflex accent
	245 => 'o',		# small o, tilde
	246 => 'o',		# small o, dieresis or umlaut mark
	248 => 'o',		# small o, slash
	249 => 'u',		# small u, grave accent
	250 => 'u',		# small u, acute accent
	251 => 'u',		# small u, circumflex accent
	252 => 'u',		# small u, dieresis or umlaut mark
	253 => 'y',		# small y, acute accent
	255 => 'y',		# small y, dieresis or umlaut mark
);

sub encurl($) {
	my ($a) = @_;

	$a =~ s|([^-./\w])|sprintf "%%%02x", ord($1)|ge;
#	$a =~ s| |+|g;
	$a;
}

sub enchtml($;$) {
	my ($a, $do_nbsp) = @_;

	$a =~ s|&|&amp;|g;
	$a =~ s|"|&quot;|g;
	$a =~ s|<|&lt;|g;
	$a =~ s|>|&gt;|g;
	$a =~ s| |&nbsp;|g if $do_nbsp;
	$a;
}

sub del_song($@) {
	my ($db, @ids) = @_;
	@ids or return;
	$db->do("DELETE FROM queue WHERE song_id=" . join(" OR song_id=", @ids));
}

sub add_song_nolock($$$@) {
	my ($db, $order, $user, @ids) = @_;

	my $firstid = shift @ids or return;
	my $q = "INSERT INTO queue (song_order, song_id, user) " .
		"VALUES ($order, $firstid, \"$user\")";
	foreach(@ids) {
		$order++;
		$q .= ",($order,$_,\"$user\")";
	}
	$db->do($q) or return undef;
	return 1;
}

sub get_queue_ids($$) {
	my ($db, $rest) = @_;

	my $res = $db->selectcol_arrayref("SELECT song_id FROM queue $rest");
	return @$res;
}


sub add_song($$@) {
	my ($db, $user, @ids) = @_;

	$db->do("LOCK TABLES queue WRITE");
	del_song($db, @ids);
	my ($order) = $db->selectrow_array("SELECT MAX(song_order) FROM queue");
	$order = 0 if $order < 0;
	my $retval = add_song_nolock($db, $order + 1, $user, @ids);
	$db->do("UNLOCK TABLES");
	return $retval;
}

sub reorder_queue($@) {
	my ($db, $order, @ids) = @_;

	foreach(@ids) {
		$db->do("UPDATE queue SET song_order=$order WHERE song_id=$_");
		$order++;
	}
}

sub move_song_to_top($@) {
	my ($db, @ids) = @_;

	$db->do("LOCK TABLES queue WRITE");
	reorder_queue($db, $#ids + 2, get_queue_ids($db, "ORDER BY song_order"));
	reorder_queue($db, 1, @ids);
	$db->do("UNLOCK TABLES");
}

sub shuffle_queue($) {
	my ($db) = @_;

	$db->do("LOCK TABLES queue WRITE");
	reorder_queue($db, 1, get_queue_ids($db, "ORDER BY rand()"));
	$db->do("UNLOCK TABLES");
}

sub kill_song(;$$) {
	my ($user, $id) = @_;
	my ($plid, $host, $port);
	local *F;

	open F, $conf{statusfile}
		or die "$conf{statusfile}: $!\n";
	$plid = <F>;
	<F>; <F>; <F>;
	chop($host = <F>);
	$port = <F>;
	close F;

	if(defined($id) && $id != $plid) { return undef; }

	if($conf{kill_song_external}) {
		system $conf{kill_song_external}, $user || '';

		open F, $conf{statusfile}
			or die "$conf{statusfile}: $!\n";
		my @lines;
		chop(@lines = <F>);
		close F;
		return @lines;
	}
	return kill_song_internal($host, $port);
}

sub kill_song_internal($$) {
	my ($host, $port) = @_;
	local *F;

	$host && $port or return undef;

	socket(F, PF_INET, SOCK_STREAM, getprotobyname('tcp'))
		or die "socket: $!\n";
	connect(F, sockaddr_in($port, inet_aton($host)))
		or die "connect $host:$port: $!\n";
	my @status;
	@status = <F>;
	close F;
	return @status;
}

sub player_cmd(;@) {
	my $res = 1;

	my $sock = IO::Socket::INET->new('localhost:2222') or return undef;
	$sock->autoflush(1);
	$response = <$sock>;	#greeting
	foreach(@_) {
		$sock->print("$_\n");
		$res = 0 if <$sock> !~ /^\+/;
	}
	$sock->close;
	return $res;
}


sub get_player_pid() {
	local *F;
	my $pid;

	open F, $conf{statusfile}
		or die "$conf{statusfile}: $!\n";
	<F>; <F>; <F>;
	$pid = 0 + <F>;
	close F;
	return $pid;
}

sub get_id($$$) {
	my ($db, $table, $value) = @_;

	my $sth = $db->prepare("SELECT id,name FROM $table WHERE binary name=?");
	if($sth->execute($value || "") >= 1) {
		my ($id, $v) = $sth->fetchrow_array;
		return $id;
	} else {
		$db->do("REPLACE INTO $table SET name=?", undef, $value)
			or die;
		return $db->{'mysql_insertid'};
	}
}

sub get_playlist_contents($$) {
	my ($dbh, $list) = @_;
	my %songids;
	my (%artistids, %albumsids, %listids);
	my (%artistids_done, %albumsids_done, %listids_done);

	my $sth_list = $dbh->prepare("SELECT type,entity_id" .
		" FROM list_contents WHERE list_id=?");
	my $sth_artist = $dbh->prepare("SELECT id FROM song WHERE artist_id=?");
	my $sth_album = $dbh->prepare("SELECT id FROM song WHERE album_id=?");
	
	$listids{$list} = 1;
	while(%artistids || %albumsids || %listids) {
		foreach(keys %listids) {
			$listids_done{$_} = 1;
			delete $listids{$_};

			$sth_list->execute($_);
			while($_ = $sth_list->fetchrow_hashref) {
				if($_->{'type'} eq 'list') {
					next if $listids_done{$_->{'entity_id'}};
					$listids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'artist') {
					next if $artistids_done{$_->{'entity_id'}};
					$artistids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'album') {
					next if $albumids_done{$_->{'entity_id'}};
					$albumids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'song') {
					$songids{$_->{'entity_id'}} = 1;
				}
			}
		}
		foreach(keys %artistids) {
			$artistids_done{$_} = 1;
			delete $artistids{$_};

			$sth_artist->execute($_);
			while($_ = $sth_artist->fetchrow_hashref) {
				$songids{$_->{'id'}} = 1;
			}
		}
		foreach(keys %albumids) {
			$albumids_done{$_} = 1;
			delete $albumids{$_};

			$sth_album->execute($_);
			while($_ = $sth_album->fetchrow_hashref) {
				$songids{$_->{'id'}} = 1;
			}
		}
	}
	return keys %songids;
}

sub get_nowplaying(;$) {
	my ($dbh) = @_;
	local *F;
	my $s = undef;

	open F, $conf{statusfile} or return undef;
	chop (($s->{id}, $s->{filename}, $s->{pid}, $s->{cdrplaypid},
	       $s->{killhost}, $s->{killport}, $s->{type},
	       $s->{user}, $s->{artist}, $s->{title}, $s->{album},
	       $s->{track}, $s->{length}, $s->{encoding}) = <F>);
	close F;

	if($dbh) {
		my $sth = $dbh->prepare(
			"SELECT artist.name as artist,album.name as album," .
			" song.artist_id as arid,song.album_id as alid, song.*" .
			" FROM song,artist,album WHERE song.artist_id=artist.id" .
			" AND song.album_id=album.id AND song.id=?");
		$sth->execute($s->{id});
		if(my $d = $sth->fetchrow_hashref) {
			$s->{alid} = $d->{alid};
			$s->{arid} = $d->{arid};
			$s->{filename} = $d->{filename};
			$s->{artist} = $d->{artist};
			$s->{title} = $d->{title};
			$s->{album} = $d->{album};
			$s->{track} = $d->{track};
			$s->{length} = $d->{length};
			$s->{encoding} = $d->{encoding};
		}
	}
	return $s;
}

sub construct_url($@) {
	my ($baseurl, $argsref) = @_;
	my $sep = "?";
	foreach(keys %$argsref) {
		$baseurl .= "$sep$_=" . encurl($$argsref{$_});
		$sep = "&";
	}
	return $baseurl;
}

sub cleanup_name {
	my ($s) = @_;
	$s =~ s/\.mp3\s*$//i;
	$s =~ s/%([0-9a-f][0-9a-f])/chr(hex($1))/eig;
	$s =~ s/([a-zA-Z])([A-Z][a-z])/$1 $2/g;
	$s = lc($s);
	$s =~ s/_/ /g;
	if($s !~ / /) { $s =~ s/\./ /g; }
	$s =~ s/^\s+|\s+$//g;
	$s =~ s/([^'\w\xc0-\xff]|^)(\w)/$1\U$2/g;
	$s =~ s/\b(o'\w)/\U$1/ig;
	$s =~ s/n T\b/n't/g;
	$s =~ s/ S\b/'s/g;
	$s =~ s/\bI M\b/I'm/g;
	$s =~ s/ ll\b/'ll/ig;
	$s =~ s/\b(i+)\b/\U$1/ig;
	$s =~ s/([eiuy]) ([rv]e)\b/$1'\L$2/ig;
	$s =~ s/\s*-\s*/ - /g;
	$s;
}

sub add_song_next($$;$) {
	my ($dbh, $currentsong, $user) = @_;

	my $ids = $dbh->selectcol_arrayref("SELECT song_id FROM queue,song ".
		"WHERE queue.song_id=song.id AND song.present");
	my %idsq;
	foreach(@$ids) { $idsq{$_} = 1; }

	my $sth = $dbh->prepare("SELECT song2.* FROM song AS song1,".
		" song AS song2 WHERE song1.id=$currentsong AND".
		" song1.artist_id = song2.artist_id AND".
		" song1.album_id = song2.album_id AND".
		" song2.track > song1.track AND".
		" song2.present ORDER BY song2.track");
	$sth->execute;
	while($_ = $sth->fetchrow_hashref) {
		if(!$idsq{$_->{id}}) {
			add_song($dbh, $user, $_->{id})
				or warn "can't add song.\n";
			return $_;
		}
	}
}


1;

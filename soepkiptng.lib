############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

use Socket;

sub encurl($) {
	my ($a) = @_;

	$a =~ s|([^-./\w])|sprintf "%%%02x", ord($1)|ge;
#	$a =~ s| |+|g;
	$a;
}

sub enchtml($;$) {
	my ($a, $do_nbsp) = @_;

	$a =~ s|&|&amp;|g;
	$a =~ s|"|&quot;|g;
	$a =~ s|<|&lt;|g;
	$a =~ s|>|&gt;|g;
	$a =~ s| |&nbsp;|g if $do_nbsp;
	$a;
}

sub del_song($@) {
	my ($db, @ids) = @_;
	@ids or return;
	$db->do("DELETE FROM queue WHERE song_id=" . join(" OR song_id=", @ids));
}

sub add_song_nolock($$$@) {
	my ($db, $order, $user, @ids) = @_;

	my $firstid = shift @ids or return;
	my $q = "INSERT INTO queue (song_order, song_id, user) " .
		"VALUES ($order, $firstid, \"$user\")";
	foreach(@ids) {
		$order++;
		$q .= ",($order,$_,\"$user\")";
	}
	$db->do($q);
}

sub get_queue_ids($$) {
	my ($db, $rest) = @_;

	my $res = $db->selectcol_arrayref("SELECT song_id FROM queue $rest");
	return @$res;
}


sub add_song($$@) {
	my ($db, $user, @ids) = @_;

	$db->do("LOCK TABLES queue WRITE");
	del_song($db, @ids);
	my ($order) = $db->selectrow_array("SELECT MAX(song_order) FROM queue");
	$order = 0 if $order < 0;
	add_song_nolock($db, $order + 1, $user, @ids);
	$db->do("UNLOCK TABLES");
}

sub reorder_queue($@) {
	my ($db, $order, @ids) = @_;

	foreach(@ids) {
		$db->do("UPDATE queue SET song_order=$order WHERE song_id=$_");
		$order++;
	}
}

sub move_song_to_top($@) {
	my ($db, @ids) = @_;

	$db->do("LOCK TABLES queue WRITE");
	reorder_queue($db, $#ids + 2, get_queue_ids($db, "ORDER BY song_order"));
	reorder_queue($db, 1, @ids);
	$db->do("UNLOCK TABLES");
}

sub shuffle_queue($) {
	my ($db) = @_;

	$db->do("LOCK TABLES queue WRITE");
	reorder_queue($db, 1, get_queue_ids($db, "ORDER BY rand()"));
	$db->do("UNLOCK TABLES");
}

sub kill_song() {
	if($kill_song_external) {
		system $kill_song_external;

		open F, $statusfile
			or die "$statusfile: $!\n";
		my @lines;
		chop(@lines = <F>);
		close F;
		return @lines;
	}
	return kill_song_internal();
}

sub kill_song_internal() {
	local *F;

	open F, $statusfile
		or die "$statusfile: $!\n";
	<F>; <F>; <F>; <F>;
	chop($host = <F>);
	$port = <F>;
	close F;

	$host && $port or return undef;

	socket(F, PF_INET, SOCK_STREAM, getprotobyname('tcp'))
		or die "socket: $!\n";
	connect(F, sockaddr_in($port, inet_aton($host)))
		or die "connect $host:$port: $!\n";
	my @status;
	@status = <F>;
	close F;
	return @status;
}

sub get_player_pid() {
	local *F;
	my $pid;

	open F, $statusfile
		or die "$statusfile: $!\n";
	<F>; <F>; <F>;
	$pid = 0 + <F>;
	close F;
	return $pid;
}

sub get_id($$$) {
	my ($db, $table, $value) = @_;

	my $sth = $db->prepare("SELECT id,name FROM $table WHERE binary name=?");
	if($sth->execute($value) >= 1) {
		my ($id, $v) = $sth->fetchrow_array;

#		# "gt" works case-insensitively !@#!@#%$@#, compare byte-by-byte
#		my ($vvalue, $vv) = ($value, $v);
#		while($vvalue) {
#			last if ord($vvalue) > ord($vv);
#			if(ord($vvalue) < ord($vv)) {
#				$db->do("UPDATE $table SET name=? WHERE id=?", undef, $value, $id)
#					or die;
#				last;
#			}
#			$vvalue =~ s/.//;
#			$vv =~ s/.//;
#		}
		return $id;
	} else {
		$db->do("REPLACE INTO $table SET name=?", undef, $value)
			or die;
		return $db->{'mysql_insertid'};
	}
}

sub get_playlist_contents($$) {
	my ($dbh, $list) = @_;
	my %songids;
	my (%artistids, %albumsids, %listids);
	my (%artistids_done, %albumsids_done, %listids_done);

	my $sth_list = $dbh->prepare("SELECT type,entity_id" .
		" FROM list_contents WHERE list_id=?");
	my $sth_artist = $dbh->prepare("SELECT id FROM song WHERE artist_id=?");
	my $sth_album = $dbh->prepare("SELECT id FROM song WHERE album_id=?");
	
	$listids{$list} = 1;
	while(%artistids || %albumsids || %listids) {
		foreach(keys %listids) {
			$listids_done{$_} = 1;
			delete $listids{$_};

			$sth_list->execute($_);
			while($_ = $sth_list->fetchrow_hashref) {
				if($_->{'type'} eq 'list') {
					next if $listids_done{$_->{'entity_id'}};
					$listids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'artist') {
					next if $artistids_done{$_->{'entity_id'}};
					$artistids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'album') {
					next if $albumids_done{$_->{'entity_id'}};
					$albumids{$_->{'entity_id'}} = 1;
				} elsif($_->{'type'} eq 'song') {
					$songids{$_->{'entity_id'}} = 1;
				}
			}
		}
		foreach(keys %artistids) {
			$artistids_done{$_} = 1;
			delete $artistids{$_};

			$sth_artist->execute($_);
			while($_ = $sth_artist->fetchrow_hashref) {
				$songids{$_->{'id'}} = 1;
			}
		}
		foreach(keys %albumids) {
			$albumids_done{$_} = 1;
			delete $albumids{$_};

			$sth_album->execute($_);
			while($_ = $sth_album->fetchrow_hashref) {
				$songids{$_->{'id'}} = 1;
			}
		}
	}
	return keys %songids;
}

sub construct_url($@) {
	my ($baseurl, $argsref) = @_;
	my $sep = "?";
	foreach(keys %$argsref) {
		$baseurl .= "$sep$_=" . encurl($$argsref{$_});
		$sep = "&";
	}
	return $baseurl;
}

sub cleanup_name {
	my ($s) = @_;
	$s =~ s/\.mp3$//;
	$s =~ s/([a-zA-Z])([A-Z])/\1 \2/g;
	$s = lc($s);
	$s =~ s/_/ /g;
	$s =~ s/^\s+|\s+$//g;
	$s =~ s/([^'\w\xc0-\xff]|^)(\w)/\1\U\2/g;
	$s =~ s/\b(o'\w)/\U\1/ig;
	$s =~ s/n T\b/n't/g;
	$s =~ s/ S\b/'s/g;
	$s =~ s/\bI M\b/I'm/g;
	$s =~ s/ ll\b/'ll/ig;
	$s =~ s/\b(i+)\b/\U\1/ig;
	$s =~ s/([eiuy]) ([rv]e)\b/\1'\L\2/ig;
	$s =~ s/-/ - /g;
	$s;
}

1;

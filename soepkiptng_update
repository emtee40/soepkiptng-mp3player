#!/usr/bin/perl
############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

my $progdir;
BEGIN {
	use Cwd qw'abs_path cwd';

	# find program directory
	$_ = $0;
	while(-l) {
		my $l = readlink or die "readlink $_: $!\n";
		if($l =~ m|^/|) { $_ = $l; } else { s|[^/]*$|/$l|; }
	}
	m|(.*)/|;
	$progdir = abs_path($1);

	unshift @INC, "$progdir/lib";
}
require "$progdir/soepkiptng.lib";
$ENV{PATH} = "$progdir/bin:$ENV{PATH}";

use DBI;
use Getopt::Std;
use MP3::Tag;
use MP3::Info;
#use Data::Dumper;

use vars qw/$opt_C $opt_d $opt_e $opt_f $opt_r $opt_q $opt_v $opt_c $opt_R $opt_p/;

sub get_wav_params($\%;$);
sub getinfo_mp3($\%);
sub getinfo_ogg($\%);
sub getinfo_mid($\%);
sub getinfo_wav($\%);
sub getinfo_pac($\%);
sub getinfo_flac($\%);
sub getinfo_shorten($\%);
sub getinfo_musepack($\%);
sub getinfo_raw($\%);
sub getinfo_aac($\%);
sub getinfo_mplayer($\%);
sub getinfo_ac3($\%);
sub getinfo_soepkip($\%);
sub read_eric_files();
sub extract_artist_title($\%);
sub is_nfs($);

getopts('Cfredqvhc:LR:p');
$force = 1 if $opt_f;
$| = 1;
$do_delete = !$opt_d && !$opt_r;
if($opt_p && scalar @ARGV == 0) { push @ARGV, "."; }

$opt_h and die <<EOF;
usage: soepkiptng_update [-defhqrvCL] [-c configfile] [-R pref] [dir...]

options:
  -c configfile : override soepkiptng config file
  -d            : turn on debugging
  -e            : don't read "ericfiles"
  -f            : force updating of info even if song is already in database
  -h            : get this help
  -q            : be quiet
  -r            : don't recurse subdirectories
  -v            : be verbose
  -C            : don't fix artist/title/album upper/lowercase
  -L            : set last_played to current time
  -R pref       : set random_pref field

Directories containing the file ".nosoepkiptng" will be skipped.
EOF

read_configfile(\%conf, $opt_c);


# for the web interface (stupid browsers/users)
$SIG{'PIPE'} = 'IGNORE';

# disable warnings (to make MP3::Tag shut up)
if($opt_q) {
	$SIG{__WARN__} = sub { };
}

$dbh = DBI->connect("DBI:$conf{'db_type'}:$conf{'db_name'}:$conf{'db_host'}", $conf{'db_user'}, $conf{'db_pass'})
	or die "can't connect to database";

read_eric_files() unless $opt_e;

# get existing filenames in database
if(scalar @ARGV) {
	@paths = grep { -d } map { abs_path $_; } @ARGV;
	@paths or exit 1; # abs_path complains for us
	$sth = $dbh->prepare("SELECT id,filename,unix_timestamp(last_played)," .
		"unix_timestamp(time_added),present FROM song WHERE (0" .
		(" OR binary filename LIKE ?" x scalar @paths) . ")");
	$sth->execute(map { "$_/%" } @paths);
} else {
	$sth = $dbh->prepare("SELECT id,filename,unix_timestamp(last_played),unix_timestamp(time_added),present FROM song WHERE filename LIKE \"/%\"");
	$sth->execute();
	@paths = split /\s+/, $conf{'mp3dirs'};
}
while(($id, $f, $l, $t, $pres) = $sth->fetchrow_array) {
	$filename{$f} = $id if $pres;
	$last_played{$f} = $l;
	$time_added{$f} = $t;
	$f =~ m|([^/]*)$|;
	$longname{$1} = $f;
	$longname_id{$1} = $id;
}

# scan music directories
if(open(FILES, "-|") == 0) {
	my @findargs = ('-type', 'f');
	$opt_r and push @findargs, '-maxdepth', 1;
	exec 'find', @paths, @findargs, '-print0';
	die "find: $!\n";
}

$/ = "\0";
while(<FILES>) {
	chop;
	# skip hidden files
	next if m|/\.[^/]+$|;
	# skip zero-length files
	next unless -s;
	m|(.*?)[^/]*$|;
	next if -e "$1/.nosoepkiptng";

	print "$_\n" if $opt_v;

	if(length($_) > 255) {
		print STDERR "Skipping $_, filename >255 chars.\n" unless $opt_q;
		next;
	}

#	if(++$num % 10 == 0) { print STDERR "."; }

	# get file encoding; skip if unknown
	my %info;
	$/ = "\n";
	getinfo_mp3($_, %info) ||
	getinfo_ogg($_, %info) ||
	getinfo_mid($_, %info) ||
	getinfo_wav($_, %info) ||
	getinfo_pac($_, %info) ||
	getinfo_flac($_, %info) ||
	getinfo_shorten($_, %info) ||
	getinfo_musepack($_, %info) ||
	getinfo_aac($_, %info) ||
	getinfo_mplayer($_, %info) ||
	getinfo_ac3($_, %info) ||
	getinfo_raw($_, %info);

	getinfo_soepkip($_, %info);

	$/ = "\0";

	$info{len} = 0 + $info{len};
	$info{encoding} or do {
		print STDERR "Filetype of $_ unknown\n" unless $opt_q;
		next;
	};
	if($info{freq} && ($info{freq} < 44090 || $info{freq} > 44110)) {
		my $s = sprintf "%f", $info{freq} / 1000;
		$s =~ s/\.?0+$//;
		push @{$info{encoding_extra}}, "${s}kHz";
	}
	if($info{chan} == 1) {
		push @{$info{encoding_extra}}, "mono";
	}
	if(@{$info{encoding_extra}}) {
		$info{encoding} .= sprintf " (%s)", join(", ", @{$info{encoding_extra}});
	}

	# check "nolocal" setting (only files on NFS are allowed)
	if($conf{nolocal} && !is_nfs($_)) {
		die "Error: file on local filesystem: $_\n";
	}

	# skip if already in database (unless "force" was given)
	if($filename{$_}) {
		if($force) {
			print "Updating $_:\n";
			$num_updated++;
		} else {
			$num_skipped++;
			delete $filename{$_};
			next;
		}
	} else {
		# check whether an old entry (ie. the file does not exist anymore)
		# exists with the same filename (without path)
		/([^\/]*)$/;
		my $oldname = $longname{$1};
		if($oldname && ($oldname eq $_ || ! -e $oldname)) {
			$dbh->do("DELETE FROM song WHERE present=0 AND id!=? AND " .
				"binary filename=?", undef, $longname_id{$1}, $_)
				or die "can't do sql command: " . $dbh->errstr . "\n";
			$dbh->do("UPDATE song SET present=1, filename=?, " .
				"length=?, encoding=? WHERE id=?", undef,
				$_, $info{len}, $info{encoding}, $longname_id{$1})
				or die "can't do sql command: " . $dbh->errstr . "\n";
			delete $filename{$oldname};
			$num_moved++;
			$oldname =~ s|[^/]+$||;
			print "Moving $_ (from $oldname)\n";
			next;
		}
		$num_added++;
		print "Adding $_:\n";
	}

	# get artist/title/track/album info
	m|([^/]+/+[^/]+)\.\w+$|;
#print STDERR "1=$1\n";
	if($track{$1}) {
		$info{info_origin} = "ericfile";
		$info{artist} = $artist{$1};
		$info{title} = $track{$1};
		$info{album} = $album{$1};
		$info{track} = $tracknr{$1};
	} elsif(!$info{info_origin}) {
		extract_artist_title($_, %info);
	} elsif(!$info{title}) {
		my %i;
		extract_artist_title($_, %i);
		$info{title} = $i{title};
	}

	if(!$info{track} && m~(^|/)(\d\d+)[^/]+$~) {
		$info{track} = $2;
		warn " (taking track ($2) from filename)\n";
	}

	printf <<EOF,
   Info from: %s
   Artist:    %s
   Title:     %s
   Album:     %s
   Track:     %d
   Length:    %d:%02d
   Encoding:  %s
EOF
	$info{info_origin},
	$info{artist},
	$info{title},
	$info{album},
	$info{track},
	$info{len} / 60, $info{len} % 60,
	$info{encoding};

	# insert song into database
	if(!$artistid_cache{$info{artist}}) {
		$artistid_cache{$info{artist}} = get_id($dbh, "artist", $info{artist}) or die;
	}
	if(!$albumid_cache{$info{album}}) {
		$albumid_cache{$info{album}} = get_id($dbh, "album", $info{album});
	}
	$q = "REPLACE INTO song SET id=?, artist_id=?, title=?, album_id=?, " .
		"track=?, present=1, filename=?, length=?, encoding=?, random_pref=?, " .
		"last_played=from_unixtime(?), time_added=from_unixtime(?)";

	$dbh->do($q, undef, $filename{$_}, $artistid_cache{$info{artist}},
		$info{title}, $albumid_cache{$info{album}}, $info{track} || 0,
		$_, $info{len}, $info{encoding}, $opt_R || 10000,
		$last_played{$_} || ($opt_L? time : 0),
		$time_added{$_} || time)
                or die "can't do sql command: " . $dbh->errstr . "\n";

	if($info{lyrics}) {
		$dbh->do("REPLACE INTO lyrics SET id=?, description=?, language=?, lyrics=?",
			undef, $filename{$_} || $dbh->{'mysql_insertid'},
			$info{description}, $info{language}, $info{lyrics})
	                or die "can't do sql command: " . $dbh->errstr . "\n";
	}
	delete $filename{$_};
}

close FILES
	or die sprintf "find: %s signal %d\n",
		(($? & 0x7f)? "killed by":"exit status"),
		(($? & 0x7f)? ($? & 0x7f) : ($? >> 8));

# delete all filenames in database what were not found on disk
if($do_delete) {
	$sth = $dbh->prepare("UPDATE song SET present=0 WHERE binary filename=?");
	foreach(keys %filename) {
		$sth->execute($_);
		print "Deleting $_\n";
		$num_deleted++;
	}
}

printf <<EOF,
%4d songs added.
%4d songs updated.
%4d songs deleted.
%4d songs moved.
%4d songs skipped.
EOF
	$num_added, $num_updated, $num_deleted, $num_moved, $num_skipped
		unless $opt_q && $num_added == 0 && $num_updated == 0
			&& $num_deleted == 0 && $num_moved == 0;

print "Optimizing Tables.\n" unless $opt_q;
$dbh->do("optimize table song");
$dbh->do("optimize table album");
$dbh->do("optimize table artist");

$dbh->disconnect();



sub get_id3($\%) {
	my ($file, $info) = @_;

	if($file =~ m|(.*/)| and -e "$1/.noid3") { return undef; }

	my $id3 = MP3::Tag->new($file);
	$id3->config("autoinfo", "ID3v2", "ID3v1");
	my ($t, $tr, $a, $alb) = $id3->autoinfo();
	
	# read lyrics
	my $tag = $id3->{ID3v2};
	if($tag) {
		my $uslt = $tag->getFrame('USLT');
		if($uslt) {
			$info->{language} = $uslt->{Language};
			$info->{lyrics} = $uslt->{Text};
			$info->{description} = $uslt->{Description};
		}
	}

	$a =~ s/_/ /g;
	$a =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $a =~ /[A-Z]/ || $opt_C;
	$t =~ s/_/ /g;
	$t =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $t =~ /[A-Z]/ || $opt_C;
	$alb =~ s/_/ /g;
	$alb =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $alb =~ /[A-Z]/ || $opt_C;

	$a && $t or return undef;

	$info->{info_origin} = $id3->{ID3v2}? "ID3v2" : "ID3";
	$info->{artist} = $a;
	$info->{title} = $t;
	$info->{album} = $alb || "";
	$info->{track} = $tr;
	return 1;
}

# used by musepack; see http://www.personal.uni-jena.de/~pfk/mpp/sv8/apetag.html
sub get_ape($\%$) {
	my ($file, $info, $offset) = @_;
	local *F;
	my $apetag;
	my $found;

	open F, $file or return undef;
	seek F, $offset, ($offset < 0? 2 : 0) or goto OUT;
	read F, $apetag, 32 or goto OUT;
	$apetag =~ /^APETAGEX/ or goto OUT;
	my ($version, $length, $tagcount, $flags) = unpack "VVVV", substr $apetag, 8;
	$version == 1000 || $version == 2000 or goto OUT;
	$length > 32 or goto OUT;
	unless(($flags >> 29) & 1) {
		seek F, -$length, 1 or goto OUT;
	}
	read F, $apetag, $length - 32 or goto OUT;
	my ($pos, $tag);
	for($pos = 0, $tag = 0; $pos < $length && $tag < $tagcount; $tag++) {
		my ($len, $fl, $name) = unpack "VVZ*", substr $apetag, $pos;
		$pos += 8 + length($name) + 1;
		if($name =~ /^(Artist|Title|Album|Track)$/) {
			$info->{lc $1} = substr $apetag, $pos, $len;
			$found++;
		}
		$pos += $len;
	}
	$found or goto OUT;
	$info->{info_origin} = sprintf "APE %d.0", $version / 1000;
OUT:
	close F;
	return $found;
}

# getinfo_* returns (description, length[sec], sfreq[khz], channels
# or undef if it isn't the correct type

sub getinfo_mp3($\%) {
	my ($file, $info) = @_;

	$file =~ /\.mp[1-3]$/i
		or return undef;

	# open file to check Xing VBR tag
	open F, $file or do {
		print STDERR "$file: $!\n";
		return "?";
	};

	# skip ID3 tag
	my $buf;
	read F, $buf, 10;
	my ($tag, $ver1, $ver2, $flags, $s1, $s2, $s3, $s4) = unpack "a3CCCCCCC", $buf;
	if($tag eq "ID3") {
		$size = (((((($s1 << 7) | $s2) << 7) | $s3) << 7) | $s4) + 10;
		seek F, $size, 1;
	}

	# read Xing VBR tag
	seek F, 26, 1;
	read F, $buf, 12;
	close F;

	my ($xtag, $xflags, $xframes);
	($xtag, $xflags, $xframes) = unpack("a4NN", $buf);
	if($xtag ne "Xing") { $xframes = 0; }

	my $mp3info = get_mp3info($file);
	$info->{len} = $mp3info->{MM} * 60 + $mp3info->{SS};
	$info->{freq} = $mp3info->{FREQUENCY} * 1000;
	$info->{chan} = $mp3info->{STEREO}? 2 : 1;

	my $bitrate = $mp3info->{BITRATE};
	if($xframes) {
		$info->{len} = $xframes * ($mp3info->{VERSION}? 1152 : 576) /
			$info->{freq};
		$bitrate = int(8 * (-s $file) / $info->{len} / 1000);
	}
	if($mp3info->{LAYER} == 3) {
		$info->{encoding} = "MP3";
	} else {
		$info->{encoding} = sprintf "MPEG-%d Layer %d",
			$mp3info->{VERSION}, $mp3info->{LAYER};
	}
	push @{$info->{encoding_extra}}, sprintf("%dkb/s", $bitrate);
	if($xframes) { push @{$info->{encoding_extra}}, "VBR"; }

	get_id3($file, %$info);

	return 1;
}

sub getinfo_ogg($\%) {
	my ($file, $info) = @_;
	local *F;

	$file =~ /\.ogg$/i
		or return undef;

	if(open(F, "-|") == 0) {
		exec "ogg2raw", "-i", $file;
		die;
	}

	my $br;
	my $infoline = <F>;
	($info->{freq}, $info->{chan}, $info->{len}, $br) = split(/,/, $infoline);
	$info->{freq} or return undef;
	$info->{encoding} = "Ogg-Vorbis";
	push @{$info->{encoding_extra}}, sprintf("%dkb/s", ($br + 500) / 1000);

	chop(($info->{artist}, $info->{title}, $info->{album},
	 $info->{track}) = <F>);
	close F;

	$info->{info_origin} = "Ogg-Vorbis" if $info->{artist} && $info->{title};
	return 1;
}

sub getinfo_wav($\%) {
	my ($file, $info) = @_;

	$file =~ /\.wav$/i
		or return undef;

	get_wav_params($file, %$info) or return undef;
	$info->{encoding} = "WAV";
	return 1;
}

sub getinfo_mid($\%) {
	my ($file, $info) = @_;

	$file =~ /\.(mid|rcp|r36|g18|g36|mod)$/i
		or return undef;

	$info->{encoding} = "Midi";
	return 1;
}

sub getinfo_pac($\%) {
	my ($file, $info) = @_;

	$file =~ /\.pac$/i
		or return undef;

	if(open(F, "-|") == 0) {
		exec "lpac2raw", "-i", $file;
		die;
	}
	my $bytes;
	($info->{freq}, $info->{chan}, $info->{len}, $bytes) = split(/,/, <F>);
	close F;
	$bytes or return undef;

	$info->{encoding} = "LPAC";
	push @{$info->{encoding_extra}}, sprintf("%d%%", (-s $file) / ($bytes / 100));
	return 1;
}

sub getinfo_flac($\%) {
	my ($file, $info) = @_;

	$file =~ /\.flac$/i
		or return undef;

	my $filesize = -s $file or return undef;

	if(open(F, "-|") == 0) {
		open STDERR, ">/dev/null";
		exec qw/metaflac
			--show-sample-rate
			--show-channels
			--show-total-samples
			--show-bps
			--show-vc-field=artist
			--show-vc-field=title
			--show-vc-field=tracknumber
			--show-vc-field=album
			/, $file;
		die;
	}
	my ($totsamp, $bps);
	($info->{freq}, $info->{chan}, $totsamp, $bps, $info->{artist},
		$info->{title}, $info->{track}, $info->{album}) = <F>;
	close F;

	my $totbytes = $totsamp * $info->{chan} * $bps / 8;
	$info->{encoding} = "flac" . ($totbytes? sprintf(" (%d%%)", 100 * $filesize / $totbytes) : "");

	$info->{artist} =~ s/^[^=]+=|\s+$//g;
	$info->{title} =~ s/^[^=]+=|\s+$//g;
	$info->{album} =~ s/^[^=]+=|\s+$//g;
	$info->{track} =~ s/^[^=]+=|\s+$//g;

	$info->{len} = $totsamp / $info->{freq};
	$info->{info_origin} = "flac" if $info->{artist} && $info->{title};
	return 1;
}

sub getinfo_shorten($\%) {
	my ($file, $info) = @_;

	$file =~ /\.shn$/i
		or return undef;

	$info->{encoding} = "Shorten";
	$info->{len} = 0;
	$info->{freq} = 44100;
	$info->{chan} = 2;
	return 1;
}

# handles only SV7 
sub getinfo_musepack($\%) {
	my ($file, $info) = @_;
	my ($buf, $id3);
	local *F;

	$file =~ /\.mp[cp+]$/i
		or return undef;
	open F, $file or do {
		warn "$file: $!\n";
		return undef;
	};
	read F, $buf, 12;
	seek F, -128, 2;
	read F, $id3, 128;
	close F;
	$buf =~ /^MP\+/ or return undef;
	my ($version, $frames, $flags) = unpack "VVV", $buf;
	$version >>= 24;
	if($version != 7) {
		warn "$_: unknown version: SV$version\n";
		return undef;
	}
	$info->{encoding} = "Musepack";
	$info->{freq} = (44100, 48000, 37800, 32000)[($flags >> 16) & 3];
	$info->{len} = $frames * 1152 / $info->{freq};
	push @{$info->{encoding_extra}}, sprintf "%dkb/s", (8 * (-s $file) / $info->{len} + 500) / 1000;
	$info->{chan} = 2;

	get_ape($file, %$info, 0) ||      # APE tag at beginning
	get_ape($file, %$info, -32) ||    # APE tag at end
	get_ape($file, %$info, -160) ||   # APE tag at end followed by ID3 tag
	get_id3($file, %$info);
	return 1;
}

sub getinfo_raw($\%) {
	my ($file, $info) = @_;

	$file =~ /\.raw$/i
		or return undef;

	$info->{encoding} = "raw";
	$info->{len} = (-s $file) / 176400;
	$info->{freq} = 44100;
	$info->{chan} = 2;
	return 1;
}

sub getinfo_mplayer($\%) {
	my ($file, $info) = @_;
	local $_;
	my %prop;

	$file =~ /\.(mpe?g|avi|asx|asf|vob|wmv|ra?m|ra|mov|m2v|wma)$/i
		or return undef;

	local *F;
	if(open(F, "-|") == 0) {
		open STDIN, "/dev/null";
		open STDERR, ">&STDOUT";
		delete $ENV{DISPLAY};
		exec qw"mplayer -identify -vo null -ao null -frames 0", $file;
		die "mplayer";
	}
	while(<F>) {
		s/\s+$//;
		/^\s+author:\s*(.*)/i and $info->{artist} = $1;
		/^\s+name:\s*(.*)/i and $info->{title} = $1;
		/^ID_(\w+)=(.*)/ and $prop{lc($1)} = $2;
	}
	close F;
	if($file =~ /\.(ra?m|ra)$/i) {
		$info->{encoding} = $prop{video_format}? "RealVideo":"RealAudio";
	} else {
		$info->{encoding} = ($prop{video_format}? "Video: ":"") . $1;
	}
	$info->{info_origin} = "Clip Info" if $info->{artist} || $info->{title};
	if($prop{video_width} && $prop{video_height}) {
		$info->{encoding} .= " ($prop{video_width}x$prop{video_height})";
	}
	if(!$prop{video_codec}) {
		# audio only
		if($prop{audio_format} >= 0x160 && $prop{audio_format} <= 0x163) {
			$info->{encoding} = "WMA";
		}
		push @{$info->{encoding_extra}}, sprintf("%dkb/s", ($prop{audio_bitrate} + 500) / 1000)
			if exists $prop{audio_bitrate};
		$info->{freq} = $prop{audio_freq};
		$info->{chan} = $prop{audio_nch};
	} else {
		$info->{freq} = 0;
		$info->{chan} = 0;
	}
	$info->{len} = $prop{length};
	return 1;
}

sub getinfo_aac($\%) {
	my ($file, $info) = @_;
	my $l;
	local *F;

	$file =~ /\.(aac|m4a)$/i
		or return undef;

	if(open(F, "-|") == 0) {
		open STDERR, ">&STDOUT";
		exec "faad", "-i", $file;
		die "faad";
	}
	while($l = <F>) {
		if($l =~ /(\w+)\s+([.\d]+)\s+secs,\s+(\d+)\s+ch,\s+(\d+)\s+Hz/) {
			$info->{encoding} = $1;
			$info->{freq} = $4;
			$info->{chan} = $3;
			$info->{len} = int($2 + 0.5);
			close F;
			return 1;
		}
	}
	close F;
	return undef;
}

sub getinfo_ac3($\%) {
	my ($file, $info) = @_;

	$file =~ /\.(ac3)$/i
		or return undef;

	$info->{encoding} = "AC3";
	$info->{freq} = 0;
	$info->{chan} = 0;
	$info->{len} = 0;
	return 1;
}

sub getinfo_soepkip($\%) {
	my ($file, $info) = @_;
	local *F;

	$file =~ s|(.*)/+||;
	my $dir = $1;

	open F, "$dir/.soepkiptng_info" or return undef;
	local $_;
	FILE: while(<F>) {
		if(/^\[([^\]]+)\]/ && $1 eq $file) {
			$info->{info_origin} = ".soepkiptng_info";
			while(<F>) {
				last FILE if /^\[/;
				s/\s+$//;
				/^(artist|album|track|title)\s*=\s*(.*)/
					and $info->{$1} = $2;
			}
			close F;
			return 1;
		}
	}
	close F;
	return undef;
}

# returns samplefreq, channels, seconds
sub get_wav_params($\%;$) {
	my ($file, $info, $offset) = @_;
	$offset = 0 + $offset;
	local *F;
	my $buf;

	open F, $file or return undef;
	FILE: for(;;) {
		if($offset) { read(F, $buf, $offset) or last; }
		read(F, $buf, 12)  or last;
		my ($riff, $len, $wave) = unpack("a4Va4", $buf);
		last if $riff ne 'RIFF' || $wave ne 'WAVE';

		# find 'fmt ' chunk
		my ($type, $len);
		for(;;) {
			read(F, $buf, 8) or last FILE;
			($type, $len) = unpack("a4V", $buf);
			last if $type eq 'fmt ';
			my $i = 0;
			while($i < $len) {
				my $r = $len < 4096? $len : 4096;
				$r = read F, $buf, $r or last FILE;
				$i += $r;
			}
		}
		read(F, $buf, $len)  or last;
		my ($fmt, $chan, $freq, $bytespersec, $align, $bitspersample) =
			unpack("vvVVvv", $buf);
#print STDERR "		my ($fmt, $chan, $freq, $bytespersec, $align, $bitspersample) =\n";
		last if $fmt != 1;

		# find 'data' chunk
		for(;;) {
			read(F, $buf, 8) or last FILE;
			($type, $len) = unpack("a4V", $buf);
			last if $type eq 'data';
			while($len) {
				my $r = $len < 4096? $len : 4096;
				$r = read F, $buf, $r or last FILE;
				$len -= $r;
			}
		}
		close F;
		$info->{len} = int($len / $bytespersec + 0.5);
		$info->{freq} = $freq;
		$info->{chan} = $chan;
		return 1;
	}
	close F;
	return undef;
}

sub read_eric_files() {
	foreach $file (split /\s+/, $conf{'description_files'}) {
		open ALB, $file or die "$file: $!\n";
		while(<ALB>) {
			/\S/ or do { $artist = $album = $dirname = ""; next; };
			/^artist\s*(.*?)\s*$/ and do { $artist = $1; next; };
			/^title\s*(.*?)\s*$/ and do { $album = $1; next; };
			if(/^dirname\s+(.*\S)/) {
				my $realartist;
	
				$dirname = $1;
				($artist_s = $dirname) =~ s/-.*//;
				while(<ALB>) {
					/^##\s*(.*\S)/ and do {
						$realartist = $1;
						next;
					};
					if(s/^track\s+(\S+)\.\w+\s*//) {
						$a = $1;
						$filename = $1;
						$a =~ s/^(\d+)-([^-]+)-.*/\2/;
						$tracknr{"$dirname/$filename"} = $1;
#print STDERR "a=$a artist_s=$artist_s artist=$artist realartist=$realartist\n";
						if($realartist) {
							$artist{"$dirname/$filename"} = $realartist;
							$realartist = undef;
						} elsif($a eq $artist_s) {
							$artist{"$dirname/$filename"} = $artist;
						} else {
							$a =~ s/_/ /g;
							$a =~ s/\b(\w)/\U\1/g;
							$artist{"$dirname/$filename"} = $a;
						}
						s/\s*$//;
						if(!$_) {
							$_ = $filename;
							s/^\d+-([^-]+)-//;
							s/_/ /g;
							s/\b(\w)/\U\1/g; 
						}
						$track{"$dirname/$filename"} = $_;
#print STDERR "{$dirname/$filename} = $_\n";
	#print qq~\$track{"$dirname/$filename"} = $_;\n~ if /magic/i;
						$album{"$dirname/$filename"} = $album;
	#print STDERR "$dirname/$filename $album\n";
					}
					last unless /\S/;
				}
			}
		}
		close ALB;
	}
};

sub extract_artist_title($\%) {
	my ($file, $info) = @_;
	my ($a, $t, $tr, $alb);
	local *F;

	$info->{info_origin} = "filename";

	# cut path
	$file =~ s|(.*)/||;
	my $p = $1;

	# cut extension
	$file =~ s/(.*)\..*/\1/;

	if(-e "$p/.andre" || ($file !~ /-/ && $file =~ /\..*\./)) {
		# andre-notatie
		$file =~ s/_ddd\.hq//;
		$file =~ s/_/-/g;
		$file =~ s/\./_/g;
		$info->{info_origin} = "filename[andre]";
	}

	my $pp = $p;
	$pp = '' if -e "$p/.noalbum";
	if(open F, "$p/.album") {
		$alb = <F>;
		close F;
		chomp $alb;
	}
	$file =~ s/\s*$//;
	if($file =~ s/^\s*(\d\d)(\D)/\2/i ||		# nummer weg, 2 digits
		$file =~ s/^\s*(\d{0,3})[^a-z0-9]+//i) 	# nummer weg, 1-3 digits met separator
	{
		$tr = $1;
	}
	$file =~ s/^[^a-z]+//i;

	$pp =~ s|/+$||;
	$pp =~ s|.*/||;

	if($file =~ /[_\s]*-[_\s]*/) {
		($a, $t) = ($`, $');
		if($pp) { ($alb = $pp) =~ s/.*-[_\s]*//; }
	} else {
		if(!$alb && $pp =~ s/-[_\s]*(.*)//) { $alb = $1; } 
		($a, $t) = ($pp, $file);
	}
	if(-e "$p/.reverse") { ($a, $t) = ($t, $a); }

	$info->{artist} = cleanup_name($a);
	$info->{title} = cleanup_name($t);
	$info->{album} = cleanup_name($alb);
	$info->{track} = $tr;

	return 1;
}

sub is_nfs($) {
	my ($file) = @_;

	# major device number must be 0
	my $maj = (stat $file)[0] >> 8;
	return $maj == 0;
}

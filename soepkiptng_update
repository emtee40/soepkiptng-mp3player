#!/usr/bin/perl
############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

BEGIN {
	$configfile = "/etc/soepkiptng.conf";

	open F, $configfile or die "$configfile: $!\n";
	while(<F>) {
		/^#/ and next;
		s/\s+$//;
		/./ or next;
		if(/^(\w+)\s*=\s*(.*?)\s*$/) {
			$f = $1;
			$conf{$f} = $2;
		} elsif(/^\s+(.*?)\s*$/) {
			# continuation line
			$conf{$f} .= "\n$1";
		} else {
			die "$configfile line $.: invalid format\n";
		}
	}
	close F;
}

$ENV{'PATH'} = "$conf{'progdir'}/bin:$ENV{'PATH'}";
require "$conf{'progdir'}/soepkiptng.lib";
use lib "$conf{'progdir'}/lib";

use Cwd;
use DBI;
use Getopt::Std;
use MP3::Tag;
use MPEG::MP3Info;
#use Data::Dumper;

use vars qw/$opt_d $opt_e $opt_f $opt_r/;

sub get_wav_params($\%;$);
sub getinfo_mp3($\%);
sub getinfo_ogg($\%);
sub getinfo_wav($\%);
sub getinfo_pac($\%);
sub getinfo_flac($\%);
sub getinfo_raw($\%);
sub read_eric_files();
sub extract_artist_title($\%);

getopts('fred');
$force = 1 if $opt_f;
$| = 1;
$do_delete = !$opt_d && !$opt_r;

# for the web interface (stupid browsers/users)
$SIG{'PIPE'} = 'IGNORE';

$dbh = DBI->connect("DBI:$conf{'db_type'}:$conf{'db_name'}:$conf{'db_host'}", $conf{'db_user'}, $conf{'db_pass'})
	or die "can't connect to database";

read_eric_files() unless $opt_e;

# get existing filenames in database
if($ARGV[0]) {
	chdir $ARGV[0] or die "$ARGV[0]: $!\n";
	@paths = (cwd);
	$sth = $dbh->prepare("SELECT id,filename,unix_timestamp(last_played),unix_timestamp(time_added),present FROM song WHERE filename LIKE ?");
	$sth->execute("$paths[0]/%");
} else {
	$sth = $dbh->prepare("SELECT id,filename,unix_timestamp(last_played),unix_timestamp(time_added),present FROM song WHERE filename LIKE \"/%\"");
	$sth->execute();
	@paths = split /\s+/, $conf{'mp3dirs'};
}
while(($id, $f, $l, $t, $pres) = $sth->fetchrow_array) {
	$filename{$f} = $id if $pres;
	$last_played{$f} = $l;
	$time_added{$f} = $t;
	$f =~ m|([^/]*)$|;
	$longname{$1} = $f;
	$longname_id{$1} = $id;
}

# scan music directories
if(open(FILES, "-|") == 0) {
	my @findargs = ('-type', 'f');
	$opt_r and push @findargs, '-maxdepth', 1;
	exec 'find', @paths, @findargs, '-print0';
	die "find: $!\n";
}

$/ = "\0";
while(<FILES>) {
	chop;
	# skip hidden files
	next if m|/\.[^/]+$|;
	# skip zero-length files
	next unless -s;
	m|(.*?)[^/]*$|;
	next if -e "$1/.nosoepkiptng";

#	if(++$num % 10 == 0) { print STDERR "."; }

	# get file encoding; skip if unknown
	my %info;
	$/ = "\n";
	getinfo_mp3($_, %info) ||
	getinfo_ogg($_, %info) ||
	getinfo_wav($_, %info) ||
	getinfo_pac($_, %info) ||
	getinfo_flac($_, %info) ||
	getinfo_raw($_, %info);
	$/ = "\0";

	$info{len} = 0 + $info{len};
	$info{encoding} or do {
		warn "Filetype of $_ unknown\n";
		next;
	};
	if($info{freq} && ($info{freq} < 44090 || $info{freq} > 44110)) {
		my $s = sprintf "%f", $info{freq} / 1000;
		$s =~ s/\.?0+$//;
		$info{encoding} .= ", ${s}kHz";
	}
	$info{encoding} .= " mono" if $info{chan} == 1;

	# skip if already in database (unless "force" was given)
	if($filename{$_}) {
		if($force) {
			print "Updating $_:\n";
			$num_updated++;
		} else {
			$num_skipped++;
			delete $filename{$_};
			next;
		}
	} else {
		# check whether an old entry (ie. the file does not exist anymore)
		# exists with the same filename (without path)
		/([^\/]*)$/;
		my $oldname = $longname{$1};
		if($oldname && ($oldname eq $_ || ! -e $oldname)) {
			$dbh->do("DELETE FROM song WHERE present=0 AND id!=? AND " .
				"filename=?", undef, $longname_id{$1}, $_)
				or die "can't do sql command: " . $dbh->errstr . "\n";
			$dbh->do("UPDATE song SET present=1, filename=?, " .
				"length=?, encoding=? WHERE id=?", undef,
				$_, $info{len}, $info{encoding}, $longname_id{$1})
				or die "can't do sql command: " . $dbh->errstr . "\n";
			delete $filename{$oldname};
			$num_moved++;
			$oldname =~ s|[^/]+$||;
			print "Moving $_ (from $oldname)\n";
			next;
		}
		$num_added++;
		print "Adding $_:\n";
	}

	# get artist/title/track/album info
	m|([^/]+/+[^/]+)\.\w+$|;
#warn "1=$1\n";
	if($track{$1}) {
		$info{info_origin} = "ericfile";
		$info{artist} = $artist{$1};
		$info{title} = $track{$1};
		$info{album} = $album{$1};
		$info{track} = $tracknr{$1};
	} elsif(!$info{info_origin}) {
		extract_artist_title($_, %info);
	}

	printf <<EOF,
   Info from: %s
   Artist:    %s
   Title:     %s
   Album:     %s
   Track:     %d
   Length:    %d:%02d
   Encoding:  %s
EOF
	$info{info_origin},
	$info{artist},
	$info{title},
	$info{album},
	$info{track},
	$info{len} / 60, $info{len} % 60,
	$info{encoding};

	# insert song into database
	if(!$artistid_cache{$info{artist}}) {
		$artistid_cache{$info{artist}} = get_id($dbh, "artist", $info{artist}) or die;
	}
	if(!$albumid_cache{$info{album}}) {
		$albumid_cache{$info{album}} = get_id($dbh, "album", $info{album});
	}
	$q = "REPLACE INTO song SET id=?, artist_id=?, title=?, album_id=?, " .
		"track=?, present=1, filename=?, length=?, encoding=?, " .
		"last_played=from_unixtime(?), time_added=from_unixtime(?)";
	$dbh->do($q, undef, $filename{$_}, $artistid_cache{$info{artist}},
		$info{title}, $albumid_cache{$info{album}}, $info{track} || 0,
		$_, $info{len},
		$info{encoding}, $last_played{$_} || 0, $time_added{$_} || time)
                or die "can't do sql command: " . $dbh->errstr . "\n";
	delete $filename{$_};
}

# delete all filenames in database what were not found on disk
if($do_delete) {
	$sth = $dbh->prepare("UPDATE song SET present=0 WHERE filename=?");
	foreach(keys %filename) {
		$sth->execute($_);
		print "Deleting $_\n";
		$num_deleted++;
	}
}

print "Optimizing Tables.\n";
$dbh->do("optimize table song");
$dbh->do("optimize table album");
$dbh->do("optimize table artist");

$dbh->disconnect();

printf <<EOF, $num_added, $num_updated, $num_deleted, $num_moved, $num_skipped;
%4d songs added.
%4d songs updated.
%4d songs deleted.
%4d songs moved.
%4d songs skipped.
EOF


sub get_id3($\%) {
	my ($file, $info) = @_;

	if($file =~ m|(.*/)| and -e "$1/.noid3") { return undef; }

	my $id3 = MP3::Tag->new($file);
	$id3->config("autoinfo", "ID3v2", "ID3v1");
	my ($t, $tr, $a, $alb) = $id3->autoinfo();

	$a =~ s/_/ /g;
	$a =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $a =~ /[A-Z]/;
	$t =~ s/_/ /g;
	$t =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $t =~ /[A-Z]/;
	$alb =~ s/_/ /g;
	$alb =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $alb =~ /[A-Z]/;

	$a && $t or return undef;

	$info->{info_origin} = $id3->{ID3v2}? "ID3v2" : "ID3";
	$info->{artist} = $a;
	$info->{title} = $t;
	$info->{album} = $alb || "";
	$info->{track} = $tr;
	return 1;
}

# getinfo_* returns (description, length[sec], sfreq[khz], channels
# or undef if it isn't the correct type

sub getinfo_mp3($\%) {
	my ($file, $info) = @_;

	$file =~ /\.mp[1-3]$/i
		or return undef;

	# open file to check Xing VBR tag
	open F, $file or do {
		warn "$file: $!\n";
		return "?";
	};

	# skip ID3 tag
	my $buf;
	read F, $buf, 10;
	my ($tag, $ver1, $ver2, $flags, $s1, $s2, $s3, $s4) = unpack "a3CCCCCCC", $buf;
	if($tag eq "ID3") {
		$size = (((((($s1 << 7) | $s2) << 7) | $s3) << 7) | $s4) + 10;
		seek F, $size, 1;
	}

	# read Xing VBR tag
	seek F, 26, 1;
	read F, $buf, 12;
	close F;

	my ($xtag, $xflags, $xframes);
	($xtag, $xflags, $xframes) = unpack("a4NN", $buf);
	if($xtag ne "Xing") { $xframes = 0; }

	my $mp3info = get_mp3info($file);
	$info->{len} = $mp3info->{MM} * 60 + $mp3info->{SS};
	$info->{freq} = $mp3info->{FREQUENCY} * 1000;
	$info->{chan} = $mp3info->{STEREO}? 2 : 1;

	my $bitrate = $mp3info->{BITRATE};
	if($xframes) {
		$info->{len} = $xframes * ($mp3info->{VERSION}? 1152 : 576) /
			$info->{freq};
		$bitrate = int(8 * (-s $file) / $info->{len} / 1000);
	}
	$info->{encoding} = sprintf "MP3 %dkb/s%s", $bitrate, $xframes? " (VBR)":"";

	get_id3($file, %$info);

	return 1;
}

sub getinfo_ogg($\%) {
	my ($file, $info) = @_;
	local *F;

	$file =~ /\.ogg$/i
		or return undef;

	if(open(F, "-|") == 0) {
		exec "ogg2raw", "-i", $file;
		die;
	}

	my $br;
	my $infoline = <F>;
	($info->{freq}, $info->{chan}, $info->{len}, $br) = split(/,/, $infoline);
	$info->{freq} or return undef;
	$info->{encoding} = sprintf "Ogg-Vorbis (%dkb/s)", ($br + 500) / 1000;

	chop(($info->{artist}, $info->{title}, $info->{album},
	 $info->{track}) = <F>);
	close F;

	$info->{info_origin} = "Ogg-Vorbis" if $info->{artist} && $info->{title};
	return 1;
}

sub getinfo_wav($\%) {
	my ($file, $info) = @_;

	$file =~ /\.wav$/i
		or return undef;

	get_wav_params($file, %$info) or return undef;
	$info->{encoding} = "WAV";
	return 1;
}

sub getinfo_pac($\%) {
	my ($file, $info) = @_;

	$file =~ /\.pac$/i
		or return undef;

	if(open(F, "-|") == 0) {
		exec "lpac2raw", "-i", $file;
		die;
	}
	my $bytes;
	($info->{freq}, $info->{chan}, $info->{len}, $bytes) = split(/,/, <F>);
	close F;
	$bytes or return undef;

	$info->{encoding} = sprintf "LPAC %d%%", (-s $file) / ($bytes / 100);
	return 1;
}

sub getinfo_flac($\%) {
	my ($file, $info) = @_;

	$file =~ /\.flac$/i
		or return undef;

	open F, $file or return undef;

	my $buf;
	read F, $buf, 26;
	close F;

	length($buf) == 26 or return undef;
	my ($magic, $l1, $num) = unpack "a4x14NN", $buf;
	$magic eq "fLaC" or return undef;

	$info->{freq} = $l1 >> 12;
	$info->{chan} = 1 + (($l1 >> 9) & 7);
	my $bt = 1 + (($l1 >> 4) & 0x1f);
	$num += ($l1 & 0xf) << 32;
	$info->{len} = $num / $info->{freq};

	my $percent = '';
	if($num && $info->{ch} && $bt) {
		$percent = sprintf " %d%%",
			(-s $file) / ($num * $info->{chan} * $bt / 8 / 100);
	}
	$info->{encoding} = "flac$percent";
	return 1;
}

sub getinfo_raw($\%) {
	my ($file, $info) = @_;

	$file =~ /\.raw$/i
		or return undef;

	$info->{encoding} = "raw";
	$info->{len} = (-s $file) / 176400;
	$info->{freq} = 44100;
	$info->{chan} = 2;
	return 1;
}

# returns samplefreq, channels, seconds
sub get_wav_params($\%;$) {
	my ($file, $info, $offset) = @_;
	$offset = 0 + $offset;
	local *F;
	my $buf;

	open F, $file or return undef;
	FILE: for(;;) {
		if($offset) { read(F, $buf, $offset) or last; }
		read(F, $buf, 12)  or last;
		my ($riff, $len, $wave) = unpack("a4Va4", $buf);
		last if $riff ne 'RIFF' || $wave ne 'WAVE';

		# find 'fmt ' chunk
		my ($type, $len);
		for(;;) {
			read(F, $buf, 8) or last FILE;
			($type, $len) = unpack("a4V", $buf);
			last if $type eq 'fmt ';
			my $i = 0;
			while($i < $len) {
				my $r = $len < 4096? $len : 4096;
				$r = read F, $buf, $r or last FILE;
				$i += $r;
			}
		}
		read(F, $buf, $len)  or last;
		my ($fmt, $chan, $freq, $bytespersec, $align, $bitspersample) =
			unpack("vvVVvv", $buf);
#warn "		my ($fmt, $chan, $freq, $bytespersec, $align, $bitspersample) =\n";
		last if $fmt != 1;

		# find 'data' chunk
		for(;;) {
			read(F, $buf, 8) or last FILE;
			($type, $len) = unpack("a4V", $buf);
			last if $type eq 'data';
			while($len) {
				my $r = $len < 4096? $len : 4096;
				$r = read F, $buf, $r or last FILE;
				$len -= $r;
			}
		}
		close F;
		$info->{len} = int($len / $bytespersec + 0.5);
		$info->{freq} = $freq;
		$info->{chan} = $chan;
		return 1;
	}
	close F;
	return undef;
}

sub read_eric_files() {
	foreach $file (split /\s+/, $conf{'description_files'}) {
		open ALB, $file or die "$file: $!\n";
		while(<ALB>) {
			/\S/ or do { $artist = $album = $dirname = ""; next; };
			/^artist\s*(.*?)\s*$/ and do { $artist = $1; next; };
			/^title\s*(.*?)\s*$/ and do { $album = $1; next; };
			if(/^dirname\s+(.*\S)/) {
				my $realartist;
	
				$dirname = $1;
				($artist_s = $dirname) =~ s/-.*//;
				while(<ALB>) {
					/^##\s*(.*\S)/ and do {
						$realartist = $1;
						next;
					};
					if(s/^track\s+(\S+)\.\w+\s*//) {
						$a = $1;
						$filename = $1;
						$a =~ s/^(\d+)-([^-]+)-.*/\2/;
						$tracknr{"$dirname/$filename"} = $1;
#warn "a=$a artist_s=$artist_s artist=$artist realartist=$realartist\n";
						if($realartist) {
							$artist{"$dirname/$filename"} = $realartist;
							$realartist = undef;
						} elsif($a eq $artist_s) {
							$artist{"$dirname/$filename"} = $artist;
						} else {
							$a =~ s/_/ /g;
							$a =~ s/\b(\w)/\U\1/g;
							$artist{"$dirname/$filename"} = $a;
						}
						s/\s*$//;
						if(!$_) {
							$_ = $filename;
							s/^\d+-([^-]+)-//;
							s/_/ /g;
							s/\b(\w)/\U\1/g; 
						}
						$track{"$dirname/$filename"} = $_;
#warn "{$dirname/$filename} = $_\n";
	#print qq~\$track{"$dirname/$filename"} = $_;\n~ if /magic/i;
	#print STDERR "$dirname/$filename $album\n";
					}
					$album{"$dirname/$filename"} = $album;
					last unless /\S/;
				}
			}
		}
		close ALB;
	}
};

sub extract_artist_title($\%) {
	my ($file, $info) = @_;
	my ($a, $t, $tr, $alb);
	local *F;

	$info->{info_origin} = "filename";

	# cut path
	$file =~ s|(.*)/||;
	my $p = $1;

	# cut extension
	$file =~ s/(.*)\..*/\1/;

	if(-e "$p/.andre" || ($file !~ /-/ && $file =~ /\..*\./)) {
		# andre-notatie
		$file =~ s/_ddd\.hq//;
		$file =~ s/_/-/g;
		$file =~ s/\./_/g;
		$info->{info_origin} = "filename[andre]";
	}

	my $pp = $p;
	$pp = '' if -e "$p/.noalbum";
	if(open F, "$p/.album") {
		$alb = <F>;
		close F;
		chomp $alb;
	}
	$file =~ s/\s*$//;
	if($file =~ s/^\s*(\d\d)(\D)/\2/i ||		# nummer weg, 2 digits
		$file =~ s/^\s*(\d{0,3})[^a-z0-9]+//i) 	# nummer weg, 1-3 digits met separator
	{
		$tr = $1;
	}
	$file =~ s/^[^a-z]+//i;
#warn $file;

	$pp =~ s|/+$||;
	$pp =~ s|.*/||;

	if($file =~ /[_\s]*-[_\s]*/) {
		($a, $t) = ($`, $');
		if($pp) { ($alb = $pp) =~ s/.*-[_\s]*//; }
	} else {
		if(!$alb && $pp =~ s/-[_\s]*(.*)//) { $alb = $1; } 
		($a, $t) = ($pp, $file);
	}
	if(-e "$p/.reverse") { ($a, $t) = ($t, $a); }

	$info->{artist} = cleanup_name($a);
	$info->{title} = cleanup_name($t);
	$info->{album} = cleanup_name($alb);
	$info->{track} = $tr;

	return 1;
}

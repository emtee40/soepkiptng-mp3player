#!/usr/bin/perl
############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

$configfile = "/etc/soepkiptng.conf";

use Cwd;
use DBI;
use Getopt::Std;
use MP3::Tag;
#use Data::Dumper;

#eval "
#use POSIX qw(locale_h);
#";
#unless($@) {
#	setlocale(LC_CTYPE, "en_US.ISO8859-1") or die;
#q}

# optional
eval "use MPEG::MP3Info;";
if($@) {
	warn "MPEG::MP3Info not found; properties of mp3 files will not be available.\n";
	$omitmp3info = 1;
}

getopts('fred');
$force = 1 if $opt_f;
$| = 1;
$do_delete = !$opt_d && !$opt_r;

# for the web interface (stupid browsers/users)
$SIG{'PIPE'} = 'IGNORE';

# read config file
open F, $configfile
	or die "$configfile: $!\n";
while(<F>) {
	/^#/ and next;
	s/\s+$//;
	/./ or next;
	if(/^(\w+)\s*=\s*(.*?)\s*$/) {
		$f = $1;
		${$f} = $2;
	} elsif(/^\s+(.*?)\s*$/) {
		# continuation line
		${$f} .= "\n$1";
	} else {
		die "$configfile line $.: invalid format\n";
	}
}
close F;

require "$progdir/soepkiptng.lib";

$dbh = DBI->connect("DBI:$db_type:$db_name:$db_host", $db_user, $db_pass)
	or die "can't connect to database";

read_eric_files() unless $opt_e;

# get existing filenames in database
if($ARGV[0]) {
	chdir $ARGV[0] or die "$ARGV[0]: $!\n";
	@paths = (cwd);
	$sth = $dbh->prepare("SELECT id,filename,unix_timestamp(last_played),present FROM song WHERE filename LIKE ?");
	$sth->execute("$paths[0]/%");
} else {
	$sth = $dbh->prepare("SELECT id,filename,unix_timestamp(last_played),present FROM song");
	$sth->execute();
	@paths = split /\s+/, $mp3dirs;
}
while(($id, $f, $l, $pres) = $sth->fetchrow_array) {
	$filename{$f} = $id if $pres;
	$last_played{$f} = $l;
	$f =~ m|([^/]*)$|;
	$longname{$1} = $f;
}

# scan mp3 directories
if(open(FILES, "-|") == 0) {
	my @findargs = ('-type', 'f');
	$opt_r and push @findargs, '-maxdepth', 1;
	exec 'find', @paths, @findargs, '-print0';
	die "find: $!\n";
}
$/ = "\0";
while(<FILES>) {
	chop;
	# skip hidden files
	next if m|/\.[^/]+$|;
	# skip zero-length files
	next unless -s;
	m|(.*?)[^/]*$|;
	next if -e "$1/.nosoepkiptng";

#	if(++$num % 10 == 0) { print STDERR "."; }

	# get file encoding; skip if unknown
	my ($desc, $len, $freq, $chan) = getinfo_mp3($_);
	$desc or ($desc, $len, $freq, $chan) = getinfo_ogg($_);
	$desc or ($desc, $len, $freq, $chan) = getinfo_wav($_);
	$desc or ($desc, $len, $freq, $chan) = getinfo_pac($_);
	$desc or ($desc, $len, $freq, $chan) = getinfo_flac($_);
	$len = 0 + $len;
	$desc or do {
		warn "Filetype of $_ unknown\n";
		next;
	};
	if($freq && ($freq < 44.09 || $freq > 44.11)) {
		my $s = sprintf "%f", $freq;
		$s =~ s/\.?0+$//;
		$desc .= ", ${s}kHz";
	}
	$desc .= " mono" if $chan == 1;

	# skip if already in database (unless "force" was given)
	if($filename{$_}) {
		if($force) {
			print "Updating $_\n";
			$num_updated++;
		} else {
			$num_skipped++;
			delete $filename{$_};
			next;
		}
	} else {
		# check whether an old entry (ie. the file does not exist anymore)
		# exists with the same filename (without path)
		/([^\/]*)$/;
		my $oldname = $longname{$1};
		if($oldname && ($oldname eq $_ || ! -e $oldname)) {
			$dbh->do("UPDATE song SET filename=?, present=1 WHERE filename=?",
				undef, $_, $oldname) or die "can't do sql command: " . $dbh->errstr . "\n";
			delete $filename{$oldname};
			$num_moved++;
			$oldname =~ s|[^/]+$||;
			print "Moving $_ (from $oldname)\n";
			next;
		}
		$num_added++;
		print "Adding $_\n";
	}

	# get artist/title/track/album info
	m|([^/]+/+[^/]+)$|;
#warn "1=$1\n";
	$artist = $artist{$1};
	$title = $track{$1};
	$album = $album{$1};
	$track = $tracknr{$1};
	if($title) {
#		print STDERR "+";
	} else {
		print STDERR "$_\n\t";
		foreach $tr (keys %track) {
			$tr =~ /^\Q$_-/ and do {
				$artist = $artist{$tr};
				$title = $track{$tr};
				$album = $album{$tr};
				print STDERR "->";
				last;
			}
		}
		$title or do {
			($artist, $title, $track, $album) = extract_artist_title($_);
			print STDERR "-->";
		};
		print STDERR "$artist :: $title ($album [$track])\n";
	}
	$album or $album = $artist{$_};
	$album or $album = "";

#	warn "a=$artist, t=$title, al=$album, tr=$track, file=$_, len=$len, desc=$desc\n";

	# insert song into database
	if(!$artistid_cache{$artist}) {
		$artistid_cache{$artist} = get_id($dbh, "artist", $artist) or die;
	}
	if(!$albumid_cache{$album}) {
		$albumid_cache{$album} = get_id($dbh, "album", $album);
	}
	$q = "REPLACE INTO song SET id=?, artist_id=?, title=?, album_id=?, " .
		"track=?, present=1, filename=?, length=?, encoding=?, " .
		"last_played=from_unixtime(?)";
	if(!$filename{$_}) { $q .= ', time_added=NULL'; }
	$dbh->do($q, undef, $filename{$_}, $artistid_cache{$artist},
		$title, $albumid_cache{$album}, $track || 0, $_, $len,
		$desc, $last_played{$_} || 0)
                or die "can't do sql command: " . $dbh->errstr . "\n";
	delete $filename{$_};
}

# delete all filenames in database what were not found on disk
if($do_delete) {
	$sth = $dbh->prepare("UPDATE song SET present=0 WHERE filename=?");
	foreach(keys %filename) {
		$sth->execute($_);
		print "Deleting $_\n";
		$num_deleted++;
	}
}

print "Optimizing Tables.\n";
$dbh->do("optimize table song");
$dbh->do("optimize table album");
$dbh->do("optimize table artist");

$dbh->disconnect();

printf <<EOF, $num_added, $num_updated, $num_deleted, $num_moved, $num_skipped;
%4d songs added.
%4d songs updated.
%4d songs deleted.
%4d songs moved.
%4d songs skipped.
EOF



# getinfo_* returns (description, length[sec], sfreq[khz], channels
# or undef if it isn't the correct type

sub getinfo_mp3($) {
	$_[0] =~ /\.mp[1-3]$/i
		or return undef;

	if($omitmp3info) {
		return ("MP3", 0, 0, 0);
	}
	# check Xing VBR tag
	my $frames = 0;
	open F, $_[0] or do {
		warn "$_[0]: $!\n";
		return "?";
	};

	my ($buf, $tag, $flags);
	seek F, 0x24, 0;
	read F, $buf, 12;
	close F;
	($tag, $flags, $frames) = unpack("a4NN", $buf);
	if($tag ne "Xing") { $frames = 0; }

	my $info = get_mp3info($_[0]);
	my $secs = 0 + $info->{MM} * 60 + $info->{SS};
	my $bitrate = $info->{BITRATE};
	if($frames) {
		$secs = $frames * ($info->{VERSION}? 1152 : 576) /
			($info->{FREQUENCY} * 1000);
		$bitrate = int(8 * (-s $_[0]) / $secs / 1000);
	}
	return (sprintf("MP3 %dkb/s%s", $bitrate, $frames? " (VBR)":""),
		$secs, 0 + $info->{FREQUENCY},
		$info->{STEREO}? 2 : 1
	);
}

sub getinfo_ogg($) {
	$_[0] =~ /\.ogg$/i
		or return undef;
	if(open(F, "-|") == 0) {
		exec "ogg2raw", "-i", $_[0];
		die;
	}
	my ($sfreq, $chan, $sec, $br) = split(/,/, <F>);
	close F;
	return (sprintf("Ogg-Vorbis (~%dkb/s)", ($br + 500) / 1000),
		0 + $sec, $sfreq / 1000, 0 + $chan
	);
}

sub getinfo_wav($) {
	$_[0] =~ /\.wav$/i
		or return undef;
	return ("WAV", get_wav_params($_[0]));
}

sub getinfo_pac($) {
	$_[0] =~ /\.pac$/i
		or return undef;
	if(open(F, "-|") == 0) {
		exec "lpac2raw", "-i", $_[0];
		die;
	}
	my ($sfreq, $chan, $sec, $bytes) = split(/,/, <F>);
	my $percent = int((-s $_[0]) / ($bytes / 100));
	
	close F;
	return ("LPAC $percent%", 0 + $sec, $sfreq / 1000, 0 + $chan);
}

sub getinfo_flac($) {
	$_[0] =~ /\.flac$/i
		or return undef;
	open F, $_[0] or return undef;

	my $buf;
	read F, $buf, 26;
	close F;

	length($buf) == 26 or return undef;
	my ($magic, $l1, $num) = unpack "a4x14NN", $buf;
	$magic eq "fLaC" or return undef;

	my $sr = $l1 >> 12;
	my $ch = 1 + (($l1 >> 9) & 7);
	my $bt = 1 + (($l1 >> 4) & 0x1f);
	$num += ($l1 & 0xf) << 32;
#warn "flac($magic, $sr, $ch, $bt, $num)\n";

	my $percent = '';
	if($num && $ch && $bt) {
		$percent = sprintf " %d%%",
			(-s $_[0]) / ($num * $ch * $bt / 8 / 100);
	}
	return ("flac$percent", $num / $sr, $sr / 1000, $ch);
}

# returns (samplefreq, channels, seconds)
sub get_wav_params($;$) {
	my ($file, $offset) = @_;
	$offset = 0 + $offset;
	local *F;
	my $buf;

	open F, $file or return undef;
	FILE: for(;;) {
		if($offset) { read(F, $buf, $offset) or last; }
		read(F, $buf, 12)  or last;
		my ($riff, $len, $wave) = unpack("a4Va4", $buf);
		last if $riff ne 'RIFF' || $wave ne 'WAVE';

		# find 'fmt ' chunk
		my ($type, $len);
		for(;;) {
			read(F, $buf, 8) or last FILE;
			($type, $len) = unpack("a4V", $buf);
			last if $type eq 'fmt ';
			my $i = 0;
			while($i < $len) {
				my $r = $len < 4096? $len : 4096;
				$r = read F, $buf, $r or last FILE;
				$i += $r;
			}
		}
		read(F, $buf, $len)  or last;
		my ($fmt, $chan, $freq, $bytespersec, $align, $bitspersample) =
			unpack("vvVVvv", $buf);
#warn "		my ($fmt, $chan, $freq, $bytespersec, $align, $bitspersample) =\n";
		last if $fmt != 1;

		# find 'data' chunk
		for(;;) {
			read(F, $buf, 8) or last FILE;
			($type, $len) = unpack("a4V", $buf);
			last if $type eq 'data';
			while($len) {
				my $r = $len < 4096? $len : 4096;
				$r = read F, $buf, $r or last FILE;
				$len -= $r;
			}
		}
		close F;
		return int($len / $bytespersec + 0.5), $freq / 1000, $chan;
	}
	close F;
	return undef;
}


sub read_eric_files() {
	foreach $file (split /\s+/, $description_files) {
		open ALB, $file or die "$file: $!\n";
		while(<ALB>) {
			/\S/ or do { $artist = $album = $dirname = ""; next; };
			/^artist\s*(.*?)\s*$/ and do { $artist = $1; next; };
			/^title\s*(.*?)\s*$/ and do { $album = $1; next; };
			if(/^dirname\s+(.*\S)/) {
				my $realartist;
	
				$dirname = $1;
				($artist_s = $dirname) =~ s/-.*//;
				while(<ALB>) {
					/^##\s*(.*\S)/ and do {
						$realartist = $1;
						next;
					};
					if(s/^track\s+(\S+)\s*//) {
						$a = $1;
						$filename = $1;
						$a =~ s/^(\d+)-([^-]+)-.*/\2/;
						$tracknr{"$dirname/$filename"} = $1;
#warn "a=$a artist_s=$artist_s artist=$artist realartist=$realartist\n";
						if($realartist) {
							$artist{"$dirname/$filename"} = $realartist;
							$realartist = undef;
						} elsif($a eq $artist_s) {
							$artist{"$dirname/$filename"} = $artist;
						} else {
							$a =~ s/_/ /g;
							$a =~ s/\b(\w)/\U\1/g;
							$artist{"$dirname/$filename"} = $a;
						}
						s/\s*$//;
						if(!$_) {
							$_ = $filename;
							s/\..*?$//;
							s/^\d+-([^-]+)-//;
							s/_/ /g;
							s/\b(\w)/\U\1/g; 
						}
						$track{"$dirname/$filename"} = $_;
#warn "{$dirname/$filename} = $_\n";
	#print qq~\$track{"$dirname/$filename"} = $_;\n~ if /magic/i;
	#print STDERR "$dirname/$filename $album\n";
					}
					$album{"$dirname/$filename"} = $album;
					last unless /\S/;
				}
			}
		}
		close ALB;
	}
};

sub extract_artist_title {
	my ($f) = @_;
	my ($a, $t, $tr, $alb);

	# cut path
	$f =~ s|(.*)/||;
	my $p = $1;

	if(!$omitmp3info && ! -e "$p/.noid3" && "$p/$f" =~ /\.mp3$/i) {
		my $mp3 = MP3::Tag->new("$p/$f");
		($t, $tr, $a, $alb) = $mp3->autoinfo();

		$a =~ s/_/ /g;
		$a =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $a =~ /[A-Z]/;
		$t =~ s/_/ /g;
		$t =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $t =~ /[A-Z]/;
		$alb =~ s/_/ /g;
		$alb =~ s/([^'\w\xc0-\xff]|^)(\w)(\S*)\b/\1\U\2\L\3/g unless $alb =~ /[A-Z]/;

		if($a && $t) {
			print STDERR "id3/id3v2";
			return ($a, $t, $tr, $alb);
		}
	}

	# cut extension
	$f =~ s/(.*)\..*/\1/;

	if(-e "$p/.andre" || ($f !~ /-/ && $f =~ /\..*\./)) {
		# andre-notatie
		$f =~ s/_ddd\.hq//;
		$f =~ s/_/-/g;
		$f =~ s/\./_/g;
		warn "ANDRE-NOTATIE: $f\n";
	}

	my $pp = $p;
	$pp = '' if -e "$p/.noalbum";
	$f =~ s/\s*$//;
	if($f =~ s/^\s*(\d\d)(\D)/\2/i ||		# nummer weg, 2 digits
		$f =~ s/^\s*(\d{0,3})[^a-z0-9]+//i) 	# nummer weg, 1-3 digits met separator
	{
		$tr = $1;
	}
	$f =~ s/^[^a-z]+//i;
#warn $f;

	$pp =~ s|/+$||;
	$pp =~ s|.*/||;

	if($f =~ /[_\s]*-[_\s]*/) {
		($a, $t) = ($`, $');
		($alb = $pp) =~ s/.*-[_\s]*//;
	} else {
		$p =~ s/-[_\s]*(.*)// and $alb = $1;
		($a, $t) = ($pp, $f);
	}
	if(-e "$p/.reverse") { ($a, $t) = ($t, $a); }
	return (cleanup_name($a), cleanup_name($t), $tr, cleanup_name($alb));
}


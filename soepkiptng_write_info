#!/usr/bin/perl
############################################################################
# soepkiptng (c) copyright 2000 Eric Lammerts <eric@lammerts.org>.
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

my $progdir;
BEGIN {
	use Cwd 'abs_path';

	# find program directory
	$_ = $0;
	while(-l) {
		my $l = readlink or die "readlink $_: $!\n";
		if($l =~ m|^/|) { $_ = $l; } else { s|[^/]*$|/$l|; }
	}
	m|(.*)/|;
	$progdir = abs_path($1);

	unshift @INC, "$progdir/lib";
}
require "$progdir/soepkiptng.lib";
$ENV{PATH} = "$progdir/bin:$ENV{PATH}";

use integer;
use DBI;
use Getopt::Std;
use MP3::Tag;
#use Data::Dumper;

use vars qw/$opt_r $opt_h $opt_q $opt_t $opt_l $opt_c/;

%latin1_to_ascii = (
	192 => "A", 193 => "A", 194 => "A", 195 => "A", 196 => "A", 197 => "A",
	198 => "AE", 199 => "C", 200 => "E", 201 => "E", 202 => "E", 203 => "E",
	204 => "I", 205 => "I", 206 => "I", 207 => "I", 209 => "N", 210 => "O",
	211 => "O", 212 => "O", 213 => "O", 214 => "O", 215 => "x", 216 => "O",
	217 => "U", 218 => "U", 219 => "U", 220 => "U", 221 => "Y", 223 => "ss",
	224 => "a", 225 => "a", 226 => "a", 227 => "a", 228 => "a", 229 => "a",
	230 => "ae", 231 => "c", 232 => "e", 233 => "e", 234 => "e", 235 => "e",
	236 => "i", 237 => "i", 238 => "i", 239 => "i", 241 => "n", 242 => "o",
	243 => "o", 244 => "o", 245 => "o", 246 => "o", 248 => "o", 249 => "u",
	250 => "u", 251 => "u", 252 => "u", 253 => "y", 255 => "y",
);

sub simplify($) {
	my ($a) = @_;

	$a =~ s/-/_/g;
	$a =~ s/[\[(](.*)/-\1/;
	$a =~ s/[ _]?&[_ ]?/_and_/;
	$a =~ s/([\xc0-\xff])/lc($latin1_to_ascii{ord($1)}) || $1/ge;
	$a =~ s/[^-A-Za-z0-9]+/_/g;
	$a =~ s/_?-_?/-/g;
	$a =~ s/_$//;
	return lc($a);
};

sub do_dir($$) {
	my ($dbh, $f) = @_;

	$f = abs_path($f);
	$f =~ s|/+$||;
	my $q = "SELECT filename,artist.name as artist,album.name as album" .
		" FROM song,artist,album" .
		" WHERE song.artist_id=artist.id AND song.album_id=album.id" .
		" AND present AND filename LIKE ?";
	my $sth = $dbh->prepare($q);
	$sth->execute("$f/%")
		or die "can't do sql command: " . $dbh->errstr;

	my $album;
	my $artist;
	my @files;
	while($_ = $sth->fetchrow_hashref) {
		(my $dir = $_->{filename}) =~ s|^(.*)/[^/]+$|\1|;
		next unless $dir eq $f;		# skip files in subdirs
		if($artist && $artist ne $_->{artist}) {
			warn "$f: No common artist name found.\n";
			return;
		}
		$artist = $_->{artist};
		if($album && $album ne $_->{album}) {
			warn "$f: No common album name found.\n";
			return;
		}
		$album = $_->{album};
		push @files, $_->{filename};
	}
	$sth->finish;
	my $newname = "";
	$newname .= simplify($artist) . "-" if $artist;
	$newname .= simplify($album);
	$f =~ m|^(.*)/|;
	$newname = "$1/$newname";

	if($f eq $newname) {
	} elsif(-e $newname) {
		warn "$f: $newname exists, skipping\n";
	} else {
		warn "renaming $f -> $newname\n";
		if(rename $f, $newname) {
			foreach(@files) {
				(my $fnew = $_) =~ s|.*/|$newname/|;
				
				$dbh->do("DELETE FROM song WHERE filename=?",
					undef, $fnew)
					or die "can't do sql command: " . $dbh->errstr;
				$dbh->do("UPDATE song SET filename=? WHERE filename=?",
					undef, $fnew, $_)
					or die "can't do sql command: " . $dbh->errstr;
			}
		} else {
			warn "rename $f -> $newname: $!\n";
		}
	}
}

sub do_file($$) {
	my ($dbh, $f) = @_;

	$f =~ s|^\./+||;
	my $fullf = $f;
	$fullf =~ m|/| or $fullf = "./$f";
	$fullf =~ s|(.*)/|abs_path($1) . "/"|e;

	$q = "SELECT song.id,title,artist.name,album.name,track,length" .
	     " FROM song,artist,album" .
	     " WHERE song.artist_id=artist.id AND song.album_id=album.id" .
	     " AND present AND filename=?";
	$sth = $dbh->prepare($q);
	$sth->execute($fullf)
		or die "can't do sql command: " . $dbh->errstr;

	($id, $ti, $ar, $al, $tr, $len) = $sth->fetchrow_array or do {
		my $shortf = $fullf;
		$shortf =~ s|^/+||;
		$q = "SELECT song.id,title,artist.name,album.name,track,length" .
		     " FROM song,artist,album" .
		     " WHERE song.artist_id=artist.id AND song.album_id=album.id" .
		     " AND present AND filename LIKE ?";
		$sth = $dbh->prepare($q);
		for(;;) {
#			warn "===== %/$shortf\n";
			$sth->execute("%/$shortf")
				or die "can't do sql command: " . $dbh->errstr;

			($id, $ti, $ar, $al, $tr, $len) = $sth->fetchrow_array
				and last;

			$shortf =~ s|[^/]+/+|| or do {
				warn "$f: not found in dbase\n" unless $opt_q;
				return 1;
			}
		}
		warn "$f: partial filename match on $shortf\n" unless $opt_q;
	};
	$sth->finish;

	next unless -s $f;

	if($f =~ /\.mp[123]$/i) {
		do_mp3($dbh, $f, $ar, $ti, $al, $tr, $len);
	} elsif($f =~ /\.flac$/i) {
		do_flac($dbh, $f, $ar, $ti, $al, $tr, $len);
	} elsif($f =~ /\.ogg$/i) {
		do_ogg($dbh, $f, $ar, $ti, $al, $tr, $len);
	} else {
		warn "unknown file type: $f\n";
	}

	if($opt_r) {
		my $ext = "";
		$f =~ /.*\.(.*?)$/ and $ext = lc($1);
		my $newname = "";
		$newname .= sprintf "%02d-", $tr if $tr;
		$newname .= simplify($ar) . "-" if $ar;
		$newname .= simplify($ti);
		if($opt_l && length("$newname.$ext") > $opt_l) {
			$newname = substr($newname, 0, $opt_l - length(".$ext") - 1);
			$newname =~ s/_?$/_/;
		}
		$newname .= ".$ext";
		$fullf =~ m|^(.*)/|;
		$newname = "$1/$newname";

		if($newname ne $fullf) {
			warn "renaming $fullf -> $newname\n";
			if(-e $newname) {
				warn "$f: $newname exists, skipping\n";
			} elsif(!$opt_t) {
				if(rename $fullf, $newname) {
					$dbh->do("DELETE FROM song WHERE filename=?",
						undef, $newname)
						or die "can't do sql command: " . $dbh->errstr;
					$dbh->do("UPDATE song SET filename=? WHERE id=?",
						undef, $newname, $id)
						or die "can't do sql command: " . $dbh->errstr;
				} else {
					warn "rename $fullf -> $newname: $!\n";
				}
			}
		}
	}
	return 1;
}

sub do_mp3($$$$$$$) {
	my ($dbh, $f, $ar, $ti, $al, $tr, $len) = @_;

	open F, "+<$f" or do {
		warn "$f: $!\n";
		return 1;
	};
	for(;;) {
		seek F, -128, 2;
		read F, $buf, 128;
		$buf =~ /^TAG/ or last;
		warn "$f: removed ID3 tag\n";
		seek F, -128, 2;
		truncate F, tell F or warn "truncate $f: $!\n"
			unless $opt_t;
		last if $opt_t;
	}
	close F;

	$mp3 = MP3::Tag->new($f) or die "$f: $!\n";
	$mp3->config("autoinfo", "ID3v2");
	my ($p_ti, $p_tr, $p_ar, $p_al) = $mp3->autoinfo();

	my $p_len = 0;
	my $newtag = $mp3->{ID3v2};
	if(defined($newtag)) {
		$p_len = $mp3->{ID3v2}->getFrame("TLEN");
		$newtag->remove_frame('TIT2');
		$newtag->remove_frame('TPE1');
		$newtag->remove_frame('TALB');
		$newtag->remove_frame('TRCK');
		$newtag->remove_frame('TLEN');
	} else {
		$newtag = $mp3->newTag('ID3v2');
	}

	if($p_ti ne $ti || $p_tr != $tr || $p_ar ne $ar || $p_al ne $al || $p_len != 1000 * $len) {
		$newtag->add_frame('TIT2', $ti) if $ti;
		$newtag->add_frame('TPE1', $ar) if $ar;
		$newtag->add_frame('TALB', $al) if $al;
		$newtag->add_frame('TRCK', $tr) if $tr;
		$newtag->add_frame('TLEN', 1000 * $len) if $len;
		warn "$f: updating ID3v2 tag\n";
		$newtag->write_tag()
			unless $opt_t;
	}
	return 1;
}

sub do_ogg($$$$$$$) {
	my ($dbh, $f, $ar, $ti, $al, $tr, $len) = @_;
	local *FR;
	local *FW;

	# read current tags & see what needs to be changed
	my $needchange = 0;
	if(open(FR, "-|") == 0) {
		exec "vorbiscomment", "-ql", $f;
		die "vorbiscomment";
	}
	while(<FR>) {
		s/\s+$//;
		if((/^artist=(.*)/ && $1 ne $ar) ||
		   (/^title=(.*)/ && $1 ne $ti) ||
		   (/^album=(.*)/ && $1 ne $al) ||
		   (/^tracknumber=(.*)/ && $1 != $tr)) {
			$needchange = 1;
			last;
		}
	}
	close FR;

	$needchange or return 1;
	warn "$f: updating vorbis comments\n";

	if(open(FR, "-|") == 0) {
		exec "vorbiscomment", "-ql", $f;
		die "vorbiscomment";
	}
	if(open(FW, "|-") == 0) {
		exec "vorbiscomment", "-qw", $f;
		die "vorbiscomment";
	}
	# print new info
	print FW <<EOF;
artist=$ar
title=$ti
album=$al
tracknumber=$tr
EOF
	# copy other tags verbatim
	while(<FR>) {
		next if /^(artist|title|album|tracknumber)=/;
		print FW $_;
	}
	close FR;
	close FW;
	return 1;
}

sub do_flac($$$$$$$) {
	my ($dbh, $f, $ar, $ti, $al, $tr, $len) = @_;
	local *F;

	# read current tags & see what needs to be changed
	my @changeargs = ();
	if(open(F, "-|") == 0) {
		exec "metaflac", "--export-vc-to=-", $f;
		die "metaflac";
	}
	while(<F>) {
		s/\s+$//;
		if(/^artist=(.*)/ && $1 ne $ar) { 
			push @changeargs, "--remove-vc-field=artist", "--set-vc-field=artist=$ar";
		} elsif(/^title=(.*)/ && $1 ne $ti) {
			push @changeargs, "--remove-vc-field=title", "--set-vc-field=title=$ti";
		} elsif(/^album=(.*)/ && $1 ne $al) {
			push @changeargs, "--remove-vc-field=album", "--set-vc-field=album=$al";
		} elsif(/^tracknumber=(.*)/ && $1 != $tr) {
			push @changeargs, "--remove-vc-field=tracknumber", "--set-vc-field=tracknumber=$tr";
		}
	}
	close F;

	# change it
	if(@changeargs) {
		warn "$f: updating vorbis comments\n";
		system "metaflac", @changeargs, $f;
	}
	return 1;
}


getopts('rhqtl:c:');

read_configfile(\%conf, $opt_c);

($prog = $0) =~ s|.*/||;
if($opt_h || !@ARGV) {
	print <<EOF;
Usage: $prog [-qrt] mp3files...

Options:
       -r : rename files.
       -q : don't warn about partial/failed filename matches.
       -t : testmode, don't actually write any tags.

$prog reads Artist/Title/Album/Track info from the SoepkipTNG
database and writes it to the specified files using ID3v2 (unless the files
already have ID3v2 tags containing the exact same info). All ID3v1 tags are
removed.

If the -r switch is used, the files are renamed to a standard format:
track-artist-title.mp3 (if there is a track number) or artist-title.mp3
(if there is no track number).
* track consists of two or more digits.
* artist may contain only alphanumeric characters and underscores.
* title may contain only alphanumeric characters, underscores and dashes.

EOF
	exit;
}

$| = 1;

my $dbh = DBI->connect("DBI:$conf{'db_type'}:$conf{'db_name'}:$conf{'db_host'}",
	$conf{'db_user'}, $conf{'db_pass'})
	or die "can't connect to database";

foreach $f (@ARGV) {
	if(-d $f) {
		do_dir($dbh, $f);
	} elsif(-s _) {
		do_file($dbh, $f);
	}
}

$dbh->disconnect();

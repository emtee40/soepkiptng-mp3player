#!/usr/bin/perl -w
############################################################################
# soepkiptngd (Soepkip The Next Generation daemon)
#
# (c) copyright 2000 Eric Lammerts <eric@lammerts.org>
#
# loosely based on `mymusic' by "caffiend" <caffiend@atdot.org>
# and `Radio Soepkip' by Andre Pool <andre@scintilla.utwente.nl>
#
# $Id$
############################################################################
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at `http://www.gnu.org/copyleft/gpl.html'.  You can also obtain it by
# writing to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
############################################################################

my $configfile = "/etc/soepkiptng.conf";

use DBI;
use Getopt::Std;
use IO::Handle;
use IO::Socket;
use POSIX ":sys_wait_h";
use Sys::Hostname;

use integer;
use strict;
use vars qw(%conf $dbh $restart $opt_d $opt_r $opt_s $cdrplaypid
	$pid_status $pid_signal $pid @preload);


sub rotatelog(;$) {
	if($_[0] or -s STDERR > 65000) {
		rename $conf{errfile}, "$conf{errfile}.old" or do {
			warn "rename $conf{errfile} -> $conf{errfile}.old: $!\n";
			return;
		};
		close STDERR;
		open STDERR, ">$conf{errfile}";
		STDERR->autoflush(1);
	}
}

sub warnrotate {
	printf STDERR "%s %s", scalar localtime, $_[0];
	rotatelog();
}

sub dierotate {
	printf STDERR "%s %s", scalar localtime, $_[0];
	rotatelog();
	exit 1;
}

sub child_reaper {
	for(;;) {
		my $p = waitpid(-1, &WNOHANG);
		return if $p < 1;
		warn sprintf "reaped child %d, sig=%d status=%d\n",
			$p, $? & 0x7f, $? >> 8;
		if($p == $cdrplaypid) {
			unlink $conf{statusfile};
			die "exiting because '$conf{playercmd}' died.\n";
		} elsif($p == $pid) {
			$pid = 0;
			$pid_status = $? >> 8;
			$pid_signal = $? & 0x7f;
			warn "player finished ($p)\n";
		}
	}
};

sub get_song_jingle() {
	my $s = undef;
	local *JINGLEDIR;

	if($conf{jingledir} && opendir JINGLEDIR, $conf{jingledir}) {
		foreach(sort readdir JINGLEDIR) {
			next if /^\./;

			warn "playing jingle $conf{jingledir}/$_\n";

			$s->{id} = -1;
			$s->{type} = 'J';
			$s->{filename} = "$conf{jingledir}/$_";
			$s->{artist} = '** Jingle **';
			$s->{album} = '';
			$s->{track} = 0;
			$s->{title} = $_;
			$s->{user} = '';
			$s->{length} = 0;
			$s->{encoding} = '';
			last;
		}
		closedir JINGLEDIR;
	}
	return $s;
}

sub get_song_queued() {
	my $s = undef;

	# get queued song
	$dbh->do("LOCK TABLES queue WRITE, song READ, artist READ, album READ");
	for(;;) {
		my $sth = $dbh->prepare(
			"SELECT queue.song_id as id,queue.song_order as song_order,".
			"       queue.user as user, artist.name as artist,".
			"       album.name as album, song.*".
			" FROM queue,song,artist,album" .
			" WHERE queue.song_id=song.id AND artist.id=song.artist_id" .
			"       AND album.id=song.album_id" .
			" ORDER BY queue.song_order" .
			" LIMIT 1"
		);
		$sth->execute or last;
		$s = $sth->fetchrow_hashref or last;
		if($s->{present}) {
			warn "playing queued $s->{filename}\n";
			$s->{type} = 'Q';

			# delete it from the queue
			$dbh->do("DELETE FROM queue WHERE song_id = $s->{id}");
			$dbh->do("UPDATE queue SET song_order = song_order - $s->{song_order} - 1");
			last;
		}

		warn "deleting non-present song $s->{id} ($s->{filename})\n";
		$dbh->do("DELETE FROM queue WHERE song_id = $s->{id}");
		$s = undef;
	}
	$dbh->do("UNLOCK TABLES");
	return $s;
}

sub get_song_random_recent() {
	no integer;
	my $s = undef;

	rand() < $conf{recent_prob} or return undef;

	my $sth = $dbh->prepare(
		"SELECT artist.name as artist, album.name as album,song.*".
		" FROM song,artist,album WHERE present AND filename LIKE '/%' AND" .
		"      artist.id=song.artist_id AND album.id=song.album_id AND" .
		" unix_timestamp(now()) - unix_timestamp(time_added) < ? AND" .
		" unix_timestamp(now()) - unix_timestamp(last_played) > ?" .
		" ORDER BY rand() LIMIT 1"
	);
	$sth->execute($conf{recent_age} * 86400, $conf{min_random_time}) or return undef;
	$s = $sth->fetchrow_hashref or return undef;

	warn "playing recent $s->{filename}\n";
	$s->{type} = 'r';
	$s->{user} = '';
	return $s;
}

sub get_song_random() {
	my $s = undef;

	my $sth = $dbh->prepare(
		"SELECT artist.name as artist, album.name as album,song.*".
		" FROM song,artist,album WHERE present AND filename LIKE '/%' AND" .
		"      artist.id=song.artist_id AND album.id=song.album_id AND" .
		" unix_timestamp(now()) - unix_timestamp(last_played) > ?" .
		" ORDER BY rand() LIMIT 1"
	);

	my $min = $conf{min_random_time};
	for(;;) {
		$sth->execute($min) or return undef;
		$s = $sth->fetchrow_hashref and last;

		# no song at all
		if($min == 0) { return undef; }

		$min >>= 1;
		warn "no random song found, retrying with min_random_time=$min\n";
	}

	warn "playing random $s->{filename}\n";
	$s->{type} = 'R';
	$s->{user} = '';

	return $s;
}

sub update_preload() {
	local *PRELOAD;

	$conf{preloadfile} or return;

	my $sth = $dbh->prepare(
		"SELECT song.id, song.filename, artist.name, album.name,".
		"       song.track, song.title, song.length, song.encoding".
		" FROM song,artist,album WHERE present AND filename LIKE '/%' AND" .
		"      artist.id=song.artist_id AND album.id=song.album_id AND" .
		" unix_timestamp(now()) - unix_timestamp(last_played) > $conf{min_random_time}" .
		" ORDER BY rand() LIMIT 10"
	);

	$sth->execute() or return;
	open PRELOAD, ">$conf{preloadfile}" or return;
	while(my @s = $sth->fetchrow_array) {
		printf PRELOAD "%s\n", join("\t", @s);
		warn "add to preload: $s[1]\n";
	}
	close PRELOAD;

	warn "update preload $conf{preloadfile}\n";
	delete $conf{preloadfile};
}

sub get_song_preload() {
	my $s = undef;

	@preload or do {
		warn "no preloads available\n";
		return undef;
	};

	($s->{id}, $s->{filename}, $s->{artist}, $s->{album}, $s->{track},
	 $s->{title}, $s->{length}, $s->{encoding}) = split /\t+/, shift @preload;
	$s->{type} = "P";
	$s->{user} = '';

	warn "playing preload $s->{filename}\n";

	return $s;
}

sub logprintf($@) {
	my ($fmt, @args) = @_;

	# write to log file
	if(open LOG, ">>$conf{logfile}") {
		printf LOG "%s $fmt\n", scalar localtime, @args;
		close LOG;
	} else {
		warn "cannot open logfile $conf{logfile}: $!\n";
	}
}

sub playshoutcast($) {
	my ($file) = @_;
	my $starttime;
	my $errors = 0;

	# append trailing slash if necessary
	# (mpg123 gets confused if it's missing)
	$file =~ m|^http:/+[^/]+/| or $file .= "/";

	for(;;) {
		$starttime = time;
		system qw/mpg123 -s -y -pnone -r44100 --stereo/, $file;
		if(time - $starttime < 60) {
			$errors++;
		} else {
			$errors = 0;
		}
		if($errors > 5) {
			die "Too many errors, giving up on $file.\n";
		}
		sleep 1;
		warn "restarting mpg123 [$file]\n";
	}
}

sub start_play($) {
	my ($filename) = @_;

	if(($pid = fork) == 0) {
		# get our own program group so our parent can kill us easily
		setpgrp;

		# restore broken pipe behavior
		$SIG{'PIPE'} = 'DEFAULT';

		# get file type
		$filename =~ /([^.]*)$/;
		my $ext = lc($1);

		if($filename =~ /^http:/) {
			playshoutcast($filename);
		} elsif($ext eq "mp2" || $ext eq "mp3") {
			exec "mp3toraw", $filename;
		} elsif($ext eq "ogg") {
			exec "ogg2raw", $filename;
		} elsif($ext =~ /^(mid|rcp|r36|g18|g36|mod)$/) {
			exec "midi2raw", $filename;
		} elsif($ext eq "wav") {
			exec "wav2raw", $filename;
		} elsif($ext eq "pac") {
			exec "lpac2raw", $filename;
		} elsif($ext eq "raw") {
			exec "cat", $filename;
		} elsif($ext eq "flac") {
			exec "flac", "-d", "-fl", $filename, "-";
		} elsif($ext =~ /^(mpe?g|avi|asx|asf|vob|wmv|rm)$/) {
			exec "soepkiptng_video", $filename;
		} elsif($ext eq "ac3") {
			exec "soepkiptng_ac3", $filename;
		} else {
			die "no player for .$ext files.\n";
		}
		die "exec failed";
	}
}

sub perish {
	my ($sig) = @_;

	unlink $conf{statusfile};
	$dbh and $dbh->disconnect;
	warn "got SIG$sig, kill -KILL -$pid and $cdrplaypid, exiting\n";
	kill 'KILL', -$pid, $cdrplaypid;
	exit;
};

getopts('dr:s:');
my $debug = 1 if $opt_d;

my $field;
open F, $configfile
	or die "$configfile: $!\n";
while(<F>) {
	/^#/ and next;
	s/\s+$//;
	/./ or next;
	if(/^(\w+)\s*=\s*(.*?)\s*$/) {
		$field = $1;
		$conf{$field} = $2;
	} elsif(/^\s+(.*?)\s*$/) {
		# continuation line
		$conf{$field} .= "\n$1";
	} else {
		die "$configfile line $.: invalid format\n";
	}
}
close F;

$ENV{'PATH'} = "$conf{progdir}/bin:$ENV{'PATH'}";

if(open ST, $conf{statusfile}) {
	my ($s, $f, $pid) = <ST>;
	close ST;
	$pid = 0 + $pid;
	if($pid) {
		kill 0, $pid
			and die "Another copy of soepkiptngd is already running! (pid $pid)\n";
	}
}

my $killsock = IO::Socket::INET->new(Listen => 5)
	or die "cannot create listening TCP socket: $!\n";
my $killhost = hostname;
my $killport = $killsock->sockport();

unless($debug) {
	if(!$opt_r) {
		fork && exit;
		chdir "/";
		setpgrp();
	}
	open STDIN, "</dev/null";
	open STDERR, ">>$conf{errfile}" or do {
		rotatelog(1);
		open STDERR, ">$conf{errfile}" or die "$conf{errfile}: $!\n";
		warn "logs rotated prematurely because of permission problems.\n";
	};
	STDERR->autoflush(1);
	$SIG{__DIE__} = \&dierotate;
	$SIG{__WARN__} = \&warnrotate;
}
sleep $opt_s if $opt_s;

warn sprintf "*** starting soepkiptngd (pid=$$) %s ***\n", '$Id$';
warn "PATH=$ENV{'PATH'}\n";

$SIG{'TERM'} = \&perish;
$SIG{'INT'} = \&perish;

$SIG{'USR1'} = sub {
	warn "setting restart flag\n";
	$restart = 1;
};

$SIG{'PIPE'} = 'IGNORE';

if($conf{preloadfile}) {
	local *PRELOAD;

	if(open PRELOAD, $conf{preloadfile}) {
		chop(@preload = <PRELOAD>);
		close PRELOAD;
		warn "preload: added " . scalar @preload . " songs.\n";
	} else {
		warn "$conf{preloadfile}: $!\n";
	}
}

if($opt_r) {
	$cdrplaypid = $opt_r;
	warn "cdrplaypid=$cdrplaypid (from -r)\n";
} else {
	# when $playercmd fails instantly, we might get SIGCHLD
	# before $cdrplaypid is set !!!
	$cdrplaypid = open STDOUT, "|$conf{playercmd}";
	warn "cdrplaypid=$cdrplaypid\n";

	# play 2 sec. of silence to get my external DAC going
	print pack("x352800");
}

# we might have missed the exiting of cdrplay, so reap once now
child_reaper();

srand;

my $num_errors = 0;
my ($killsock_conn);
for(;;) {
	my ($song, $childtime);

	if($restart) {
		# close-on-exec apparently doesn't work
#		$dbh->disconnect;
		$killsock_conn and $killsock_conn->close();
		$killsock->close();
		unlink $conf{statusfile};

		warn "execing myself\n";
		exec "$conf{progdir}/soepkiptngd", '-r', $cdrplaypid;
		die "$conf{progdir}/soepkiptngd: $!\n";
	}

	if($num_errors > 1) {
		# exponential backoff in retries, max 1024 sec. (17 min 4 s)
		sleep 1 << ($num_errors < 10? $num_errors : 10);
	}

	# (re)open database connection if necessary
	if(!$dbh) {
		$dbh = DBI->connect("DBI:mysql:$conf{db_name}:$conf{db_host}",
			$conf{db_user}, $conf{db_pass}) or warn
				"Can't connect to database $conf{db_name}" .
				"\@$conf{db_host} as user $conf{db_user}\n";
	}

	if($dbh) {
		$song = get_song_jingle() || get_song_queued() ||
			get_song_random_recent() || get_song_random();

		if($song->{id}) {
			# update database
			$dbh->do("UPDATE song set last_played=NULL where id=$song->{id}");

			update_preload();
		} else {
			warn "no song found.\n";
			$dbh->disconnect;
			$dbh = undef;
			$num_errors++;
			next;
		}
	} else {
		$song = get_song_preload() or do {
			$num_errors++;
			next;
		};
	}

	# write to log file
	logprintf("%s %6d %s", $song->{type}, $song->{id}, $song->{filename});

	# launch player
	my $starttime = time;
	if($debug) {
		my ($a, $b, $c, $d) = times;
		$childtime = $c + $d;
	}
	start_play($song->{filename});
	warn "pid=$pid\n";

	# write status file
	my $status = <<EOF;
$song->{id}
$song->{filename}
$$
$cdrplaypid
$killhost
$killport
$song->{type}
$song->{user}
$song->{artist}
$song->{title}
$song->{album}
$song->{track}
$song->{length}
$song->{encoding}
EOF
	if(open ST, ">$conf{statusfile}.tmp") {
		print ST $status;
		close ST;
		rename "$conf{statusfile}.tmp", $conf{statusfile}
			or warn "cannot rename $conf{statusfile}.tmp -> $conf{statusfile}: $!\n";
	} else {
		warn "cannot open statusfile $conf{statusfile}: $!\n";
	}

	# close accepted socket after statusfile was updated
	if($killsock_conn) {
		print $killsock_conn $status;
		$killsock_conn->close();
		undef $killsock_conn;
	}

	# wait until player is done or we get a connect on $killsock
	my ($rin, $rout);
	vec($rin = '', $killsock->fileno(), 1) = 1;
	for(;;) {
		child_reaper();
		last if $pid == 0;
		if(select($rout = $rin, undef, undef, 0.1) == 1) {
			warn "got connection\n";

			# kill player
			my $p = $pid;
			if($p) {
				warn "kill -KILL -$p\n";
				kill 'KILL', -$p
					or warn "kill -KILL -$p: $!\n";
			}

			# tell cdrplay to flush its buffers
			warn "kill -USR1 $cdrplaypid\n";
			kill 'SIGUSR1', $cdrplaypid
				or warn "kill -USR1 $cdrplaypid: $!\n";

			# accept the tcp connection; we close it later,
			# after a new song has been selected
			$killsock_conn = $killsock->accept();

			# write to log file
			logprintf("K %6d", $song->{id});
		}
	}
	if(($pid_status || $pid_signal) && !$killsock_conn) {
		# write to log file
		logprintf("E %6d status=%d signal=%d", $song->{id}, $pid_status, $pid_signal);
		$num_errors++;
	} else {
		$num_errors = 0;
	}

	if($debug) {
		my ($a, $b, $c, $d) = times;
		$childtime = $c + $d - $childtime;
		warn "song finished, time=$childtime\n";
	}

	# delete jingle files
	if($song->{type} eq 'J') {
		unlink "$song->{filename}" or warn "unlink $song->{filename}: $!\n";
	}

	# prevent us from eating 100% cpu time in case of misconfiguration
	time == $starttime and $num_errors++;
}

